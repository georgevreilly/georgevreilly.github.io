<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Recursive Generators in Python 2 and 3</title>
  <link media="all" href="/style.css" rel="stylesheet" />
  <link media="all" href="/pygments.css" rel="stylesheet" />
  <link href="/favicon.ico" rel="shortcut icon" />
    <link href="/sitemap.xml" type="application/xml" rel="sitemap" title="Sitemap">
  <link href="/" rel="home start" />
  <link href="/atom/" type="application/atom+xml" rel="alternate" title="Atom Feed" />
  <link href="/rss/" type="application/rss+xml" rel="alternate" title="RSS Feed" />
    <meta name="description" content="\ 

    Generators decouple iteration from the cod..." />
    <meta name="keywords" content="python, metabrite, til" />
</head>
<body>
  <header>
    <h1><a href="/" rel="home start" class="blogtitle">George V. Reilly</a></h1>
    <nav>
      <ul>
        <li><a href="/blog/" rel="home start" title="George's full blog">blog</a></li>
        <li><a href="/til/" rel="home start" title="Today George Learned">TIL</a></li>
        <li><a href="/about/" rel="home start" title="About George">about</a></li>
        <li><a href="/atom/" rel="alternate" title="Atom Feed">atom</a></li>
        <li><a href="/rss/" rel="alternate" title="RSS Feed">rss</a></li>
        <li><a href="/articles/" rel="contents">articles</a></li>
        <li><a href="/tags/" rel="contents">tags</a></li>
      </ul>
    </nav>
  </header>
    
        <article>
    <header>
        <time datetime="2016-01-22">2016-01-22</time>
        <h1>
            <a href="/blog/2016/01/22/PythonRecursiveGenerators.html" rel="bookmark canonical">Recursive Generators in Python 2 and 3</a>
        </h1>
    </header>
    <p></p>
<blockquote>
<p>Generators decouple iteration from the code
that uses the results of the&nbsp;iteration.</p>
<p class="attribution">&mdash;David Beazley, <a class="reference external" href="https://www.dabeaz.com/generators/">Generators</a></p>
</blockquote>
<blockquote>
[Pre&shy;vi&shy;ous&shy;ly published at the now defunct <a class="reference external" href="https://web.archive.org/web/20171001220321/http://devblog.metabrite.com/">MetaBrite Dev Blog</a>.]</blockquote>
<p>Python generators have a <a class="reference external" href="https://www.dabeaz.com/generators/">variety of uses</a>.
One such is to lazily evaluate sequences.
Another is for <a class="reference external" href="https://www.dabeaz.com/coroutines/">coroutines</a>.
Yet another is to re&shy;cur&shy;sive&shy;ly traverse a tree or a graph,
yielding an iterable&nbsp;sequence.</p>
<p>Consider this simple tree of&nbsp;nodes:</p>
<pre class="code python literal-block">
<span class="n">node_tree</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span>
    <span class="s1">'a'</span><span class="p">,</span> <span class="p">[</span>
        <span class="n">Node</span><span class="p">(</span><span class="s1">'b'</span><span class="p">,</span> <span class="p">[</span>
            <span class="n">Node</span><span class="p">(</span><span class="s1">'e'</span><span class="p">,</span> <span class="p">[</span>
                <span class="n">Node</span><span class="p">(</span><span class="s1">'g'</span><span class="p">)</span>
            <span class="p">]),</span>
            <span class="n">Node</span><span class="p">(</span><span class="s1">'f'</span><span class="p">),</span>
        <span class="p">]),</span>
        <span class="n">Node</span><span class="p">(</span><span class="s1">'c'</span><span class="p">),</span>
        <span class="n">Node</span><span class="p">(</span><span class="s1">'d'</span><span class="p">)</span>
    <span class="p">])</span>
</pre>
<p>where <tt class="docutils literal">Node</tt> is defined&nbsp;as:</p>
<pre class="code python literal-block">
<span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">children</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Node(</span><span class="si">{0}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
</pre>
<p>This generator re&shy;cur&shy;sive&shy;ly traverses the nodes&nbsp;top-down:</p>
<pre class="code python literal-block">
<span class="nd">&#64;classmethod</span>
<span class="k">def</span> <span class="nf">get_tree</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="k">yield</span> <span class="n">node</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span> <span class="ow">or</span> <span class="p">[]:</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_tree</span><span class="p">(</span><span class="n">child</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">n</span>
</pre>
<p>Now we can consume <tt class="docutils literal">get_tree</tt> as a simple&nbsp;sequence:</p>
<pre class="code python literal-block">
<span class="nb">print</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">Node</span><span class="o">.</span><span class="n">get_tree</span><span class="p">(</span><span class="n">node_tree</span><span class="p">)])</span>

<span class="p">[</span><span class="n">Node</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">Node</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">Node</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">Node</span><span class="p">(</span><span class="n">g</span><span class="p">),</span> <span class="n">Node</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">Node</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">Node</span><span class="p">(</span><span class="n">d</span><span class="p">)]</span>
</pre>
<p>The first <tt class="docutils literal">yield</tt> in <tt class="docutils literal">get_tree</tt> produces the current node.
The <tt class="docutils literal">yield</tt> in the inner loop is necessary
to percolate the results of lower levels upwards to the outermost&nbsp;caller.</p>
<p>Adding some prints may clarify what&#8217;s going&nbsp;on:</p>
<pre class="code python literal-block">
<span class="nd">&#64;classmethod</span>
<span class="k">def</span> <span class="nf">get_tree</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{0}</span><span class="s2">yield 1: node=</span><span class="si">{1}</span><span class="s2"> depth=</span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">'</span><span class="se">\t</span><span class="s1">'</span><span class="o">*</span><span class="n">depth</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">depth</span><span class="p">))</span>
    <span class="k">yield</span> <span class="n">node</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span> <span class="ow">or</span> <span class="p">[]:</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_tree</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">yield 2: node=</span><span class="si">{1}</span><span class="s2"> depth=</span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">'</span><span class="se">\t</span><span class="s1">'</span><span class="o">*</span><span class="n">depth</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">depth</span><span class="p">))</span>
            <span class="k">yield</span> <span class="n">n</span>
</pre>
<p><tt class="docutils literal">yield 1</tt> produces the actual node value and occurs first,
while <tt class="docutils literal">yield 2</tt> denotes the value bubbling up to the original&nbsp;caller.:</p>
<pre class="literal-block">
    yield 1: node=Node(a) depth=1

        yield 1: node=Node(b) depth=2
    yield 2: node=Node(b) depth=1

            yield 1: node=Node(e) depth=3
        yield 2: node=Node(e) depth=2
    yield 2: node=Node(e) depth=1

                yield 1: node=Node(g) depth=4
            yield 2: node=Node(g) depth=3
        yield 2: node=Node(g) depth=2
    yield 2: node=Node(g) depth=1

            yield 1: node=Node(f) depth=3
        yield 2: node=Node(f) depth=2
    yield 2: node=Node(f) depth=1

        yield 1: node=Node(c) depth=2
    yield 2: node=Node(c) depth=1

        yield 1: node=Node(d) depth=2
    yield 2: node=Node(d) depth=1

[Node(a), Node(b), Node(e), Node(g), Node(f), Node(c), Node(d)]
</pre>
<p>You might be tempted to omit the inner loop consuming the sub-generator,
and just <tt class="docutils literal">yield</tt> the recursive&nbsp;call:</p>
<pre class="code python literal-block">
<span class="nd">&#64;classmethod</span>
<span class="k">def</span> <span class="nf">get_tree</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{0}</span><span class="s2">yield 1: node=</span><span class="si">{1}</span><span class="s2"> depth=</span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">'</span><span class="se">\t</span><span class="s1">'</span><span class="o">*</span><span class="n">depth</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">depth</span><span class="p">))</span>
    <span class="k">yield</span> <span class="n">node</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span> <span class="ow">or</span> <span class="p">[]:</span>
        <span class="k">yield</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_tree</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</pre>
<p>This&nbsp;produces:</p>
<pre class="literal-block">
    yield 1: node=Node(a) depth=1

[Node(a), &lt;generator object get_tree at 0x106f12eb0&gt;, &lt;generator object get_tree at 0x106f12f00&gt;,
 &lt;generator object get_tree at 0x106f12f50&gt;]
</pre>
<p>The call to <tt class="docutils literal">get_tree</tt> in the <tt class="docutils literal">child</tt> loop creates a generator object.
It&#8217;s not until you iterate through that nested generator object
that child results are&nbsp;yielded.</p>
<p>What happens if you omit the second <tt class="docutils literal">yield</tt>, leaving a naked recursive&nbsp;call?</p>
<pre class="code python literal-block">
<span class="nd">&#64;classmethod</span>
<span class="k">def</span> <span class="nf">get_tree</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{0}</span><span class="s2">yield 1: node=</span><span class="si">{1}</span><span class="s2"> depth=</span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">'</span><span class="se">\t</span><span class="s1">'</span><span class="o">*</span><span class="n">depth</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">depth</span><span class="p">))</span>
    <span class="k">yield</span> <span class="n">node</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span> <span class="ow">or</span> <span class="p">[]:</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">get_tree</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</pre>
<p>This produces even fewer&nbsp;results:</p>
<pre class="literal-block">
    yield 1: node=Node(a) depth=1

[Node(a)]
</pre>
<p>So the inner loop to consume the sub-generator and re-yield is nec&shy;es&shy;sary—at least in Python 2.
This is somewhat ugly and <a class="reference external" href="https://www.python.org/dev/peps/pep-0380/"><span class="caps">PEP</span> 0380</a> introduced <tt class="docutils literal">yield from</tt> in Python 3.3,
which delegates to&nbsp;sub-generators:</p>
<pre class="code python literal-block">
<span class="nd">&#64;classmethod</span>
<span class="k">def</span> <span class="nf">get_tree3</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{0}</span><span class="s2">yield 1: node=</span><span class="si">{1}</span><span class="s2"> depth=</span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">'</span><span class="se">\t</span><span class="s1">'</span><span class="o">*</span><span class="n">depth</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">depth</span><span class="p">))</span>
    <span class="k">yield</span> <span class="n">node</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span> <span class="ow">or</span> <span class="p">[]:</span>
        <span class="k">yield from</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_tree3</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</pre>
<p>Now the output&nbsp;is:</p>
<pre class="literal-block">
    yield 1: node=Node(a) depth=1

        yield 1: node=Node(b) depth=2

            yield 1: node=Node(e) depth=3

                yield 1: node=Node(g) depth=4

            yield 1: node=Node(f) depth=3

        yield 1: node=Node(c) depth=2

        yield 1: node=Node(d) depth=2

[Node(a), Node(b), Node(e), Node(g), Node(f), Node(c), Node(d)]
</pre>
<p>This is only one of several uses for <tt class="docutils literal">yield from</tt>,
which functions as a <a class="reference external" href="https://stackoverflow.com/a/26109157/6364">trans&shy;par&shy;ent two-way channel</a>
between the caller and the&nbsp;sub-generator.</p>

    <footer>
        
        
            <p>tagged as
                <a href="/tag/python/" rel="tag">python</a>,
                <a href="/tag/metabrite/" rel="tag">metabrite</a>
                    and
                    
                <a href="/tag/til/" rel="tag">til</a>
                
            </p>
        
    </footer>
    <div class="comments">
        <div id="disqus_thread"></div>
        <script type="text/javascript">
            var disqus_shortname = 'georgevreilly'; // required: replace example with your forum shortname

            // The following are highly recommended additional parameters. Remove the slashes in front to use.
            var disqus_identifier = "https://www.georgevreilly.com/blog/2016/01/22/PythonRecursiveGenerators.html";
            var disqus_url = "https://www.georgevreilly.com/blog/2016/01/22/PythonRecursiveGenerators.html";

            if (window.location.hostname != "localhost") {
                /* * * DON'T EDIT BELOW THIS LINE * * */
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        </script>
        <noscript>
            <p>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></p>
        </noscript>
        <a href="https://disqus.com" class="dsq-brlink">
            blog comments powered by <span class="logo-disqus">Disqus</span>
        </a>
        </div>
</article>


    
    
        <a href="/blog/2016/01/21/ReviewTheBlackEyedBlonde.html" class="page floatright">
        Review: The Black-Eyed Blonde &raquo;
        </a>
    
    
        <a href="/blog/2016/01/23/ReviewSherlockHolmes2010Film.html" class="page floatleft">
        &laquo; Review: Sherlock Holmes (2010 film)
        </a>
<footer>
    
    
    <p>written by <a href="mailto:george@reilly.org">George V. Reilly</a></p>
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="copyright license">
        <img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="by-nc-sa" />
    </a>
    <script data-goatcounter="https://georgevreilly.goatcounter.com/count"
            async src="//gc.zgo.at/count.js"></script>
    
    

  </footer>
</body>
</html>
