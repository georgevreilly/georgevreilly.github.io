<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Exploring Wordle</title>
  <link media="all" href="/style.css" rel="stylesheet" />
  <link media="all" href="/pygments.css" rel="stylesheet" />
  <link href="/favicon.ico" rel="shortcut icon" />
    <link href="/sitemap.xml" type="application/xml" rel="sitemap" title="Sitemap">
  <link href="/" rel="home start" />
  <link href="/atom/" type="application/atom+xml" rel="alternate" title="Atom Feed" />
  <link href="/rss/" type="application/rss+xml" rel="alternate" title="RSS Feed" />
    <meta name="description" content="Unless YOUVE LIVED UNDER ROCKS, you&#39;ve heard of Wo..." />
    <meta name="keywords" content="python, wordle" />
</head>
<body>
  <header>
    <h1><a href="/" rel="home start" class="blogtitle">George V. Reilly</a></h1>
    <nav>
      <ul>
        <li><a href="/blog/" rel="home start" title="George's full blog">blog</a></li>
        <li><a href="/til/" rel="home start" title="Today George Learned">TIL</a></li>
        <li><a href="/about/" rel="home start" title="About George">about</a></li>
        <li><a href="/atom/" rel="alternate" title="Atom Feed">atom</a></li>
        <li><a href="/rss/" rel="alternate" title="RSS Feed">rss</a></li>
        <li><a href="/articles/" rel="contents">articles</a></li>
        <li><a href="/tags/" rel="contents">tags</a></li>
      </ul>
    </nav>
  </header>
    
        <article>
    <header>
        <time datetime="2023-09-26">2023-09-26</time>
        <h1>
            <a href="/2023/09/26/ExploringWordle.html" rel="bookmark canonical">Exploring Wordle</a>
        </h1>
    </header>
    <p>Unless YOUVE LIVED UNDER ROCKS, you've heard of <a class="reference external" href="https://en.wikipedia.org/wiki/Wordle">Wordle</a>,
the online word game that has become wildly popular since late 2021.
You've probably seen people posting their Wordle games
as grids of little green, yellow, and black (or white) emojis on social media.</p>
<div class="line-block">
<div class="line">Wordle 797 4/6</div>
<div class="line"><br /></div>
<div class="line">‚¨õ ‚¨õ ‚¨õ ‚¨õ üü®</div>
<div class="line">üü® ‚¨õ üü© ‚¨õ ‚¨õ</div>
<div class="line">‚¨õ ‚¨õ üü© üü® ‚¨õ</div>
<div class="line">üü© üü© üü© üü© üü©</div>
</div>
<p>The problem that I want to address in this post is:</p>
<blockquote>
Given some <tt class="docutils literal">GUESS=SCORE</tt> pairs for Wordle and a word list,
pro&shy;gram&shy;mat&shy;i&shy;cal&shy;ly find all the words from the list
that are eligible as answers.</blockquote>
<p>Let's look at this four-round game for Wordle 797:</p>
<table class="wordle">
  <tr><td class="absent">J</td> <td class="absent">U</td> <td class="absent">D</td> <td class="absent">G</td> <td class="present">E</td> <td class="gs">JUDGE=....e</td></tr>
  <tr><td class="present">C</td> <td class="absent">H</td> <td class="correct">E</td> <td class="absent">S</td> <td class="absent">T</td> <td class="gs">CHEST=c.E..</td></tr>
  <tr><td class="absent">W</td> <td class="absent">R</td> <td class="correct">E</td> <td class="present">C</td> <td class="absent">K</td> <td class="gs">WRECK=..Ec.</td></tr>
  <tr><td class="correct">O</td> <td class="correct">C</td> <td class="correct">E</td> <td class="correct">A</td> <td class="correct">N</td> <td class="gs">OCEAN=OCEAN</td></tr>
</table><p>The letters of each guess are colored Green, Yellow, or Black (dark-gray).</p>
<ul class="simple">
<li>A Green tile üü© means that the letter is <strong>correct</strong>:
<tt class="docutils literal">E</tt> is the third letter of the answer.</li>
<li>A Yellow tile üü® means that the letter is <strong>present</strong> <em>elsewhere</em> in the answer.
There is a <tt class="docutils literal">C</tt> in the answer;
it's not in columns 1 or 4, but it is correct in column 2.
Likewise, an <tt class="docutils literal">E</tt> is present in the answer;
it's not in column 5, but it's correct in column 3.</li>
<li>A Black tile ‚¨õ is <strong>absent</strong> from the answer:
<tt class="docutils literal">J</tt>, <tt class="docutils literal">U</tt>, <tt class="docutils literal">D</tt>, <tt class="docutils literal">G</tt>,
<tt class="docutils literal">H</tt>, <tt class="docutils literal">S</tt>, <tt class="docutils literal">T</tt>,
<tt class="docutils literal">W</tt>, <tt class="docutils literal">R</tt>, and <tt class="docutils literal">K</tt>
do not appear anywhere in <tt class="docutils literal">OCEAN</tt>.</li>
</ul>
<p>(This definition of ‚Äúabsent‚Äù turns out to be inadequate,
as you will discover later.)</p>
<p>The <tt class="docutils literal">GUESS=SCORE</tt> notation is intended to be clear to read
and also easier to write than Greens and Yellows.
For example:</p>
<div style="text-align: center; font-family: &#x27;Source Code Pro&#x27;, monospace; font-size: 48px;">
    <div><i>GUESS=SCORE</i></div>
    <div>CHEST=c.E..</div>
</div>

<table class="wordle">
  <tr><td class="present">C</td> <td class="absent">H</td> <td class="correct">E</td> <td class="absent">S</td> <td class="absent">T</td></tr>
</table><ul class="simple">
<li>the <em>uppercase</em> <tt class="docutils literal">E</tt> at position 3 in the score denotes that
<tt class="docutils literal">E</tt> is in the <strong>correct</strong> position (i.e., green üü©);</li>
<li>the <em>lowercase</em> <tt class="docutils literal">c</tt> at position 1 in the score denotes that
<tt class="docutils literal">C</tt> is <strong>present</strong> somewhere in the answer,
but it is in the wrong position (yellow üü®);</li>
<li>the <tt class="docutils literal">.</tt>s in the score at positions 2, 4, and 5 denote that
the cor&shy;re&shy;spond&shy;ing letters in the guess
(<tt class="docutils literal">H</tt>, <tt class="docutils literal">S</tt>, and <tt class="docutils literal">T</tt>, re&shy;spec&shy;tive&shy;ly)
are <strong>absent</strong> from the answer (black ‚¨õ).</li>
</ul>
<div class="section" id="deducing-constraints">
<h2>Deducing Con&shy;straints</h2>
<p>What can we deduce from the first three rows of guesses,
<tt class="docutils literal"><span class="pre">JUDGE=....e</span> CHEST=c.E.. <span class="pre">WRECK=..Ec.</span></tt>?</p>
<p>There is a set of <em>valid</em> letters,
<tt class="docutils literal">C</tt> and <tt class="docutils literal">E</tt>,
that are either <em>present</em> (yellow üü®) or <em>correct</em> (green üü©).
Both <tt class="docutils literal">E</tt> and <tt class="docutils literal">C</tt> start out as present,
but <tt class="docutils literal">E</tt> later finds its correct position,
while <tt class="docutils literal">C</tt> does not.</p>
<p>There is a set of <em>invalid</em> letters that are
known to be <em>absent</em> from the answer (black ‚¨õ):
<tt class="docutils literal">J</tt>, <tt class="docutils literal">U</tt>, <tt class="docutils literal">D</tt>, <tt class="docutils literal">G</tt>, <tt class="docutils literal">H</tt>, <tt class="docutils literal">S</tt>, <tt class="docutils literal">T</tt>, <tt class="docutils literal">W</tt>, <tt class="docutils literal">R</tt>, and <tt class="docutils literal">K</tt>.</p>
<p>The remaining letters of the alphabet are currently <em>unknown</em>.
When they are played, they will turn into <em>valid</em> or <em>invalid</em> letters.
Unless we already have all five correct letters,
we will draw candidate letters from the unknown pool.</p>
<p>Fur&shy;ther&shy;more, we know something about <em>letter positions</em>.
The <em>correct</em> letters are in the correct positions,
while the <em>present</em> letters are in the wrong positions.</p>
<p>A candidate word <em>must</em>:</p>
<ol class="arabic simple">
<li>include all valid letters ‚Äî          <tt class="docutils literal">C</tt> and <tt class="docutils literal">E</tt></li>
<li>exclude all invalid letters ‚Äî        <tt class="docutils literal">JUDGHSTWRK</tt></li>
<li>match all ‚Äúcorrect‚Äù positions ‚Äî      <tt class="docutils literal">3:E</tt></li>
<li>not match any ‚Äúpresent‚Äù positions ‚Äî  <tt class="docutils literal">1:C</tt>, <tt class="docutils literal">4:C</tt>, or <tt class="docutils literal">5:E</tt></li>
</ol>
<p>These con&shy;straints narrow the possible choices from the word list.</p>
<p>The obvious way to solve this with a computer
is to codify the con&shy;straints provided by previous guess‚Äìs&shy;core pairs
and run through the entire list of words
to find eligible words.
But no human solves Wordle by me&shy;thod&shy;i&shy;cal&shy;ly examining thousands of words.
Instead, you rack your brain for
‚Äúwhat ends in <tt class="docutils literal">SE</tt> and has an <tt class="docutils literal">M</tt>?‚Äù or
‚ÄúI've tried <tt class="docutils literal">A</tt>, <tt class="docutils literal">E</tt>, and <tt class="docutils literal">I</tt>; will <tt class="docutils literal">O</tt> or <tt class="docutils literal">U</tt> work?‚Äù or
‚ÄúWhat are the most likely letters left on the keyboard at the bottom?‚Äù</p>
<p>This article will show you how to solve Wordle pro&shy;gram&shy;mat&shy;i&shy;cal&shy;ly.
It won't help you much in playing Wordle by hand,
though you may understand more about the game when you're finished reading.</p>
</div>
<div class="section" id="prototyping-with-pipes">
<h2>Pro&shy;to&shy;typ&shy;ing with Pipes</h2>
<p>Let's prototype the above con&shy;straints with a series of <a class="reference external" href="https://www.cyberciti.biz/faq/howto-use-grep-command-in-linux-unix/">grep's</a>
in a <a class="reference external" href="https://en.wikipedia.org/wiki/Pipeline_(Unix)">Unix pipeline</a> tailored to this <tt class="docutils literal">OCEAN</tt> example:</p>
<pre class="code bash literal-block">
<span class="c1"># JUDGE=....e CHEST=c.E.. WRECK=..Ec.
</span><span class="w">
</span>grep<span class="w"> </span><span class="s1">'^.....$'</span><span class="w"> </span>/usr/share/dict/words<span class="w"> </span><span class="p">|</span><span class="w">  </span><span class="c1"># Extract five-letter words
</span><span class="w">    </span>tr<span class="w"> </span><span class="s1">'a-z'</span><span class="w"> </span><span class="s1">'A-Z'</span><span class="w"> </span><span class="p">|</span><span class="w">                    </span><span class="c1"># Translate each word to uppercase
</span><span class="w">    </span>grep<span class="w"> </span><span class="s1">'^..E..$'</span><span class="w"> </span><span class="p">|</span><span class="w">                    </span><span class="c1"># Match CORRECT positions
</span><span class="w">    </span>awk<span class="w"> </span><span class="s1">'/C/ &amp;&amp; /E/'</span><span class="w"> </span><span class="p">|</span><span class="w">                  </span><span class="c1"># Match ALL of VALID set, CORRECT|PRESENT
</span><span class="w">    </span>grep<span class="w"> </span>-v<span class="w"> </span><span class="s1">'[JUDGHSTWRK]'</span><span class="w"> </span><span class="p">|</span><span class="w">            </span><span class="c1"># Exclude INVALID set
</span><span class="w">    </span>grep<span class="w"> </span><span class="s1">'^[^C]..[^C][^E]$'</span><span class="w">             </span><span class="c1"># Exclude PRESENT positions</span>
</pre>
<p>gives:</p>
<pre class="literal-block">
ICENI
ILEAC
OCEAN
OLEIC
</pre>
<p>(This was in Bash, on macOS 13.6.
Zsh doesn't like the comments in the middle of the multi-line pipeline,
so you may have to omit them.
Other operating systems will have different versions of <tt class="docutils literal">/usr/share/dict/words</tt>
that may not have all of these obscure words.)</p>
<p>We can accomplish this with only the simplest features of regular ex&shy;pres&shy;sions:
the <a class="reference external" href="https://www.regular-expressions.info/dot.html">dot metachar&shy;ac&shy;ter</a> (<tt class="docutils literal">.</tt>),
<a class="reference external" href="https://www.regular-expressions.info/charclass.html">character classes</a> (<tt class="docutils literal"><span class="pre">[JUD...]</span></tt>)
and negated character classes (<tt class="docutils literal">[^E]</tt>),
and the <tt class="docutils literal">^</tt> and <tt class="docutils literal">$</tt> <a class="reference external" href="https://www.regular-expressions.info/anchors.html">anchors</a>.
Awk gives us <a class="reference external" href="/blog/2023/09/05/RegexConjunctions.html">regex con&shy;junc&shy;tions</a>, allowing us to match <em>all</em> of the chars.</p>
<p>The above regular ex&shy;pres&shy;sions are
a simple mechanical trans&shy;for&shy;ma&shy;tion of the guess‚Äìs&shy;core pairs.
They could be simplified.
For example, after <tt class="docutils literal">grep <span class="pre">'^..E..$'</span></tt>,
the <tt class="docutils literal">E</tt> in <tt class="docutils literal">awk '/C/ &amp;&amp; /E/'</tt> is redundant.
We're not going to optimize the regexes, however.</p>
<p>Three of the four answers‚Äî<tt class="docutils literal">ICENI</tt>, <tt class="docutils literal">ILEAC</tt>, and <tt class="docutils literal">OLEIC</tt>‚Äîare far too obscure to be Wordle answers.
Actual Wordle answers also exclude simple plurals (<tt class="docutils literal">YARDS</tt>)
and simple past tense (<tt class="docutils literal">LIKED</tt>),
but allow more complex plurals (<tt class="docutils literal">BOXES</tt>)
and irregular past tense (<tt class="docutils literal">DWELT</tt>, <tt class="docutils literal">BROKE</tt>).
We make no attempt to judge if an eligible word is <em>likely</em> as a Wordle answer;
merely that it fits.</p>
<p>Let's make a pipeline for Wordle 787 (<tt class="docutils literal">INDEX</tt>):</p>
<pre class="code bash literal-block">
<span class="c1"># VOUCH=..... GRIPE=..i.e DENIM=deni. WIDEN=.iDEn
</span><span class="w">
</span>grep<span class="w"> </span><span class="s1">'^.....$'</span><span class="w"> </span>/usr/share/dict/words<span class="w"> </span><span class="p">|</span><span class="w">
    </span>tr<span class="w"> </span><span class="s1">'a-z'</span><span class="w"> </span><span class="s1">'A-Z'</span><span class="w"> </span><span class="p">|</span><span class="w">
    </span>grep<span class="w"> </span><span class="s1">'^..DE.$'</span><span class="w"> </span><span class="p">|</span><span class="w">                    </span><span class="c1"># CORRECT pos
</span><span class="w">    </span>awk<span class="w"> </span><span class="s1">'/D/ &amp;&amp; /E/ &amp;&amp; /I/ &amp;&amp; /N/'</span><span class="w"> </span><span class="p">|</span><span class="w">    </span><span class="c1"># VALID set
</span><span class="w">    </span>grep<span class="w"> </span>-v<span class="w"> </span><span class="s1">'[VOUCHGRPMW]'</span><span class="w"> </span><span class="p">|</span><span class="w">            </span><span class="c1"># INVALID set
</span><span class="w">    </span>grep<span class="w"> </span><span class="s1">'^[^D][^EI][^IN][^I][^EN]$'</span><span class="w">    </span><span class="c1"># PRESENT pos</span>
</pre>
<p>yields:</p>
<pre class="literal-block">
INDEX
</pre>
<p>This approach is promising,
but con&shy;struct&shy;ing those regexes by hand is not main&shy;tain&shy;able.</p>
</div>
<div class="section" id="initial-python-solution">
<h2>Initial Python Solution</h2>
<p>Let's attempt to solve this in Python.
The first piece is to parse a list of <tt class="docutils literal">GUESS=SCORE</tt> pairs.</p>
<!-- wordle1 -->
<pre class="code python literal-block">
<span class="k">def</span> <span class="nf">parse_guesses</span><span class="p">(</span><span class="n">guess_scores</span><span class="p">):</span><span class="w">
</span>    <span class="n">invalid</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>                         <span class="c1"># Black/Absent</span><span class="w">
</span>    <span class="n">valid</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>                           <span class="c1"># Green/Correct or Yellow/Present</span><span class="w">
</span>    <span class="n">mask</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">5</span>                       <span class="c1"># Exact match for pos (Green/Correct)</span><span class="w">
</span>    <span class="n">wrong_spot</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>  <span class="c1"># Wrong spot (Yellow/Present)</span><span class="w">
</span>    <span class="k">for</span> <span class="n">gs</span> <span class="ow">in</span> <span class="n">guess_scores</span><span class="p">:</span><span class="w">
</span>        <span class="n">guess</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="n">gs</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)</span><span class="w">
</span>        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">guess</span><span class="p">,</span> <span class="n">score</span><span class="p">)):</span><span class="w">
</span>            <span class="k">assert</span> <span class="s2">&quot;A&quot;</span> <span class="o">&lt;=</span> <span class="n">g</span> <span class="o">&lt;=</span> <span class="s2">&quot;Z&quot;</span><span class="p">,</span> <span class="s2">&quot;GUESS should be uppercase&quot;</span><span class="w">
</span>            <span class="k">if</span> <span class="s2">&quot;A&quot;</span> <span class="o">&lt;=</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span><span class="w">
</span>                <span class="k">assert</span> <span class="n">g</span> <span class="o">==</span> <span class="n">s</span><span class="w">
</span>                <span class="n">valid</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w">
</span>                <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="w">
</span>            <span class="k">elif</span> <span class="s2">&quot;a&quot;</span> <span class="o">&lt;=</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="s2">&quot;z&quot;</span><span class="p">:</span><span class="w">
</span>                <span class="k">assert</span> <span class="n">g</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="w">
</span>                <span class="n">valid</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w">
</span>                <span class="n">wrong_spot</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w">
</span>            <span class="k">elif</span> <span class="n">s</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span><span class="p">:</span><span class="w">
</span>                <span class="n">invalid</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w">
</span>            <span class="k">else</span><span class="p">:</span><span class="w">
</span>                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected </span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="n">g</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="w">
</span>    <span class="k">return</span> <span class="p">(</span><span class="n">invalid</span><span class="p">,</span> <span class="n">valid</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">wrong_spot</span><span class="p">)</span>
</pre>
<p>Let's try it for the <tt class="docutils literal">OCEAN</tt> guesses:</p>
<pre class="code pycon literal-block">
<span class="gp">&gt;&gt;&gt; </span><span class="n">invalid</span><span class="p">,</span> <span class="n">valid</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">wrong_spot</span> <span class="o">=</span> <span class="n">parse_guesses</span><span class="p">(</span><span class="w">
</span><span class="gp">... </span>    <span class="p">[</span><span class="s2">&quot;JUDGE=....e&quot;</span><span class="p">,</span> <span class="s2">&quot;CHEST=c.E..&quot;</span><span class="p">,</span> <span class="s2">&quot;WRECK=..Ec.&quot;</span><span class="p">])</span><span class="w">
</span><span class="go">
</span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">invalid</span><span class="si">=}</span><span class="se">\n</span><span class="si">{</span><span class="n">valid</span><span class="si">=}</span><span class="se">\n</span><span class="si">{</span><span class="n">mask</span><span class="si">=}</span><span class="se">\n</span><span class="si">{</span><span class="n">wrong_spot</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span><span class="w">
</span><span class="go">invalid={'H', 'K', 'D', 'G', 'T', 'R', 'U', 'W', 'J', 'S'}
valid={'E', 'C'}
mask=[None, None, 'E', None, None]
wrong_spot=[{'C'}, set(), set(), {'C'}, {'E'}]

</span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">vocab</span><span class="p">:</span><span class="w">
</span><span class="gp">... </span>    <span class="k">if</span> <span class="n">is_eligible</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">invalid</span><span class="p">,</span> <span class="n">valid</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">wrong_spot</span><span class="p">):</span><span class="w">
</span><span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="w">
</span><span class="gp">...</span><span class="w">
</span><span class="go">ICENI
ILEAC
OCEAN
OLEIC</span>
</pre>
<p>Here's the <tt class="docutils literal">is_el&shy;i&shy;gi&shy;ble</tt> function.
We <a class="reference external" href="https://www.geeksforgeeks.org/short-circuiting-techniques-python/#">short-circuit the evaluation</a> and
return as soon as any condition is <tt class="docutils literal">False</tt>.</p>
<!-- wordle1 -->
<pre class="code python literal-block">
<span class="k">def</span> <span class="nf">is_eligible</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">invalid</span><span class="p">,</span> <span class="n">valid</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">wrong_spot</span><span class="p">):</span><span class="w">
</span>    <span class="n">letters</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">word</span><span class="p">}</span><span class="w">
</span>    <span class="k">if</span> <span class="n">letters</span> <span class="o">&amp;</span> <span class="n">valid</span> <span class="o">!=</span> <span class="n">valid</span><span class="p">:</span><span class="w">
</span>        <span class="c1"># Missing some 'valid' letters from the word;</span><span class="w">
</span>        <span class="c1"># all Green/Correct and Yellow/Present letters are required</span><span class="w">
</span>        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;!Valid: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span><span class="w">
</span>        <span class="k">return</span> <span class="kc">False</span><span class="w">
</span>    <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">m</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">mask</span><span class="p">)):</span><span class="w">
</span>        <span class="c1"># Some of the Green/Correct letters are not at their positions</span><span class="w">
</span>        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;!Mask: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span><span class="w">
</span>        <span class="k">return</span> <span class="kc">False</span><span class="w">
</span>    <span class="k">elif</span> <span class="n">letters</span> <span class="o">&amp;</span> <span class="n">invalid</span><span class="p">:</span><span class="w">
</span>        <span class="c1"># Some invalid (Black/Absent) letters are in the word</span><span class="w">
</span>        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Invalid: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span><span class="w">
</span>        <span class="k">return</span> <span class="kc">False</span><span class="w">
</span>    <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span> <span class="ow">in</span> <span class="n">ws</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">ws</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">wrong_spot</span><span class="p">)):</span><span class="w">
</span>        <span class="c1"># We have valid letters in the wrong position (Yellow/Present)</span><span class="w">
</span>        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;WrongSpot: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span><span class="w">
</span>        <span class="k">return</span> <span class="kc">False</span><span class="w">
</span>    <span class="k">else</span><span class="p">:</span><span class="w">
</span>        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Got: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span><span class="w">
</span>        <span class="k">return</span> <span class="kc">True</span>
</pre>
</div>
<div class="section" id="converting-to-classes">
<h2>Converting to Classes</h2>
<p>Returning four parallel col&shy;lec&shy;tions from a function is a <a class="reference external" href="https://pragmaticways.com/31-code-smells-you-must-know/">code smell</a>.
Let's refactor these functions into a <tt class="docutils literal">WordleGuess&shy;es</tt> class.</p>
<p>First, we'll need some helper classes:</p>
<ul class="simple">
<li><tt class="docutils literal">WordleEr&shy;ror</tt>: an exception class;</li>
<li><tt class="docutils literal">TileState</tt>: a <a class="reference external" href="/blog/2023/09/02/PythonEnumsWithAttributes.html">multi-attribute enu&shy;mer&shy;a&shy;tion</a>;</li>
<li><tt class="docutils literal">GuessScore</tt>: a <a class="reference external" href="https://realpython.com/python-data-classes/">dataclass</a> that manages a guess‚Äìs&shy;core pair
and the associated <tt class="docutils literal">TileState</tt>s.</li>
<li>We'll also use <a class="reference external" href="https://bernat.tech/posts/the-state-of-type-hints-in-python/">type an&shy;no&shy;ta&shy;tions</a> because it's 2023.</li>
</ul>
<!-- wordle2 -->
<pre class="code python literal-block">
<span class="n">WORDLE_LEN</span> <span class="o">=</span> <span class="mi">5</span><span class="w">

</span><span class="k">class</span> <span class="nc">WordleError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span><span class="w">
   </span><span class="sd">&quot;&quot;&quot;Base exception class&quot;&quot;&quot;</span><span class="w">

</span><span class="k">class</span> <span class="nc">TileState</span><span class="p">(</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;TileState&quot;</span><span class="p">,</span> <span class="s2">&quot;value emoji color css_color&quot;</span><span class="p">),</span> <span class="n">Enum</span><span class="p">):</span><span class="w">
</span>    <span class="n">CORRECT</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\U0001F7E9</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;Green&quot;</span><span class="p">,</span>  <span class="s2">&quot;#6aaa64&quot;</span><span class="w">
</span>    <span class="n">PRESENT</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\U0001F7E8</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;Yellow&quot;</span><span class="p">,</span> <span class="s2">&quot;#c9b458&quot;</span><span class="w">
</span>    <span class="n">ABSENT</span>  <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\U00002B1B</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;Black&quot;</span><span class="p">,</span>  <span class="s2">&quot;#838184&quot;</span><span class="w">

</span><span class="nd">&#64;dataclass</span><span class="w">
</span><span class="k">class</span> <span class="nc">GuessScore</span><span class="p">:</span><span class="w">
</span>    <span class="n">guess</span><span class="p">:</span> <span class="nb">str</span><span class="w">
</span>    <span class="n">score</span><span class="p">:</span> <span class="nb">str</span><span class="w">
</span>    <span class="n">tiles</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">TileState</span><span class="p">]</span><span class="w">

</span>    <span class="nd">&#64;classmethod</span><span class="w">
</span>    <span class="k">def</span> <span class="nf">make</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">guess_score</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;GuessScore&quot;</span><span class="p">:</span><span class="w">
</span>        <span class="n">guess</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="n">guess_score</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)</span><span class="w">
</span>        <span class="n">tiles</span> <span class="o">=</span> <span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="n">tile_state</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">score</span><span class="p">]</span><span class="w">
</span>        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">guess</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">tiles</span><span class="p">)</span><span class="w">

</span>    <span class="nd">&#64;classmethod</span><span class="w">
</span>    <span class="k">def</span> <span class="nf">tile_state</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">score_tile</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TileState</span><span class="p">:</span><span class="w">
</span>        <span class="k">if</span> <span class="s2">&quot;A&quot;</span> <span class="o">&lt;=</span> <span class="n">score_tile</span> <span class="o">&lt;=</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span><span class="w">
</span>            <span class="k">return</span> <span class="n">TileState</span><span class="o">.</span><span class="n">CORRECT</span><span class="w">
</span>        <span class="k">elif</span> <span class="s2">&quot;a&quot;</span> <span class="o">&lt;=</span> <span class="n">score_tile</span> <span class="o">&lt;=</span> <span class="s2">&quot;z&quot;</span><span class="p">:</span><span class="w">
</span>            <span class="k">return</span> <span class="n">TileState</span><span class="o">.</span><span class="n">PRESENT</span><span class="w">
</span>        <span class="k">elif</span> <span class="n">score_tile</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span><span class="p">:</span><span class="w">
</span>            <span class="k">return</span> <span class="n">TileState</span><span class="o">.</span><span class="n">ABSENT</span><span class="w">
</span>        <span class="k">else</span><span class="p">:</span><span class="w">
</span>            <span class="k">raise</span> <span class="n">WordleError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid score: </span><span class="si">{</span><span class="n">score_tile</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="w">

</span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><span class="w">
</span>        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">guess</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">score</span><span class="si">}</span><span class="s2">&quot;</span><span class="w">

</span>    <span class="k">def</span> <span class="nf">emojis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span><span class="w">
</span>        <span class="k">return</span> <span class="n">separator</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">emoji</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">)</span>
</pre>
<p>For brevity, I presented a minimal version of <tt class="docutils literal">GuessScore.make</tt> above.
The version in my <a class="reference external" href="https://github.com/georgevreilly/wordle">Wordle repository</a> has robust validation.</p>
<p>Let's add the main class, <tt class="docutils literal">WordleGuess&shy;es</tt>:</p>
<!-- wordle2 -->
<pre class="code python literal-block">
<span class="nd">&#64;dataclass</span><span class="w">
</span><span class="k">class</span> <span class="nc">WordleGuesses</span><span class="p">:</span><span class="w">
</span>    <span class="n">mask</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span>      <span class="c1"># Exact match for position (Green/Correct)</span><span class="w">
</span>    <span class="n">valid</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>             <span class="c1"># Green/Correct or Yellow/Present</span><span class="w">
</span>    <span class="n">invalid</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>           <span class="c1"># Black/Absent</span><span class="w">
</span>    <span class="n">wrong_spot</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span>  <span class="c1"># Wrong spot (Yellow/Present)</span><span class="w">
</span>    <span class="n">guess_scores</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">GuessScore</span><span class="p">]</span><span class="w">

</span>    <span class="nd">&#64;classmethod</span><span class="w">
</span>    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">guess_scores</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">GuessScore</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;WordleGuesses&quot;</span><span class="p">:</span><span class="w">
</span>        <span class="n">mask</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">WORDLE_LEN</span><span class="w">
</span>        <span class="n">valid</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span><span class="w">
</span>        <span class="n">invalid</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span><span class="w">
</span>        <span class="n">wrong_spot</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">WORDLE_LEN</span><span class="p">)]</span><span class="w">

</span>        <span class="k">for</span> <span class="n">gs</span> <span class="ow">in</span> <span class="n">guess_scores</span><span class="p">:</span><span class="w">
</span>            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">gs</span><span class="o">.</span><span class="n">tiles</span><span class="p">,</span> <span class="n">gs</span><span class="o">.</span><span class="n">guess</span><span class="p">)):</span><span class="w">
</span>                <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="n">TileState</span><span class="o">.</span><span class="n">CORRECT</span><span class="p">:</span><span class="w">
</span>                    <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="w">
</span>                    <span class="n">valid</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w">
</span>                <span class="k">elif</span> <span class="n">t</span> <span class="ow">is</span> <span class="n">TileState</span><span class="o">.</span><span class="n">PRESENT</span><span class="p">:</span><span class="w">
</span>                    <span class="n">wrong_spot</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w">
</span>                    <span class="n">valid</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w">
</span>                <span class="k">elif</span> <span class="n">t</span> <span class="ow">is</span> <span class="n">TileState</span><span class="o">.</span><span class="n">ABSENT</span><span class="p">:</span><span class="w">
</span>                    <span class="n">invalid</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w">

</span>        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">valid</span><span class="p">,</span> <span class="n">invalid</span><span class="p">,</span> <span class="n">wrong_spot</span><span class="p">,</span> <span class="n">guess_scores</span><span class="p">)</span>
</pre>
<p><tt class="docutils literal">WordleGuess&shy;es.parse</tt> is a bit shorter and clearer than <tt class="docutils literal">parse_guess&shy;es</tt>.
It uses <tt class="docutils literal">TileState</tt> at each position
to classify the current tile and
accumulate state in the four member col&shy;lec&shy;tions.
Since <tt class="docutils literal">GuessScore.make</tt> has validated the input,
<tt class="docutils literal">parse</tt> doesn't need to do any further validation.</p>
<p>The <tt class="docutils literal">is_el&shy;i&shy;gi&shy;ble</tt> method is es&shy;sen&shy;tial&shy;ly the same as its pre&shy;de&shy;ces&shy;sor:</p>
<!-- wordle2 -->
<pre class="code python literal-block">
<span class="k">class</span> <span class="nc">WordleGuesses</span><span class="p">:</span><span class="w">
</span>    <span class="k">def</span> <span class="nf">is_eligible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span><span class="w">
</span>        <span class="n">letters</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">word</span><span class="p">}</span><span class="w">
</span>        <span class="k">if</span> <span class="n">letters</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">valid</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">valid</span><span class="p">:</span><span class="w">
</span>            <span class="c1"># Did not have the full set of green+yellow letters known to be valid</span><span class="w">
</span>            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;!Valid: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span><span class="w">
</span>            <span class="k">return</span> <span class="kc">False</span><span class="w">
</span>        <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">m</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)):</span><span class="w">
</span>            <span class="c1"># Couldn't find all the green/correct letters</span><span class="w">
</span>            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;!Mask: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span><span class="w">
</span>            <span class="k">return</span> <span class="kc">False</span><span class="w">
</span>        <span class="k">elif</span> <span class="n">letters</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">invalid</span><span class="p">:</span><span class="w">
</span>            <span class="c1"># Invalid (black) letters are in the word</span><span class="w">
</span>            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Invalid: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span><span class="w">
</span>            <span class="k">return</span> <span class="kc">False</span><span class="w">
</span>        <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span> <span class="ow">in</span> <span class="n">ws</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">ws</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrong_spot</span><span class="p">)):</span><span class="w">
</span>            <span class="c1"># Found some yellow letters: valid letters in wrong position</span><span class="w">
</span>            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;WrongSpot: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span><span class="w">
</span>            <span class="k">return</span> <span class="kc">False</span><span class="w">
</span>        <span class="k">else</span><span class="p">:</span><span class="w">
</span>            <span class="c1"># Potentially valid</span><span class="w">
</span>            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Got: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span><span class="w">
</span>            <span class="k">return</span> <span class="kc">True</span><span class="w">

</span>    <span class="k">def</span> <span class="nf">find_eligible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vocabulary</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span><span class="w">
</span>        <span class="k">return</span> <span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">vocabulary</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_eligible</span><span class="p">(</span><span class="n">w</span><span class="p">)]</span>
</pre>
<p>There's a <a class="reference external" href="https://www.spinellis.gr/blog/20200225/">famous story</a> where Donald Knuth
was asked by Jon Bentley to demon&shy;strate <a class="reference external" href="http://www.literateprogramming.com/">literate pro&shy;gram&shy;ming</a>
by finding the <em>K</em> most common words from a text file.
Knuth turned in an eight-page gem of WEB, which was reviewed by Doug McIlroy,
who demon&shy;strat&shy;ed that the task could also be ac&shy;com&shy;plished in a six-line pipeline.</p>
<p>Wordle can also be solved with a six-line pipeline,
but the regexes are quite difficult to type correctly
and they have to be carefully hand tailored
for each set of guess‚Äìs&shy;core pairs.
There is no one general six-line pipeline.</p>
<p>I know that I'd much rather work with these Python classes.
As we'll see below, they are a solid foundation
that can be built upon in many ways.</p>
</div>
<div class="section" id="does-it-work">
<h2>Does it Work?</h2>
<p>Let's try it!:</p>
<pre class="code bash literal-block">
<span class="c1"># answer: ARBOR
</span>$<span class="w"> </span>./wordle.py<span class="w"> </span><span class="nv">HARES</span><span class="o">=</span>.ar..<span class="w"> </span><span class="nv">GUILT</span><span class="o">=</span>.....<span class="w"> </span><span class="nv">CROAK</span><span class="o">=</span>.Roa.<span class="w"> </span><span class="nv">BRAVO</span><span class="o">=</span>bRa.o<span class="w">
</span>ARBOR<span class="w">

</span><span class="c1"># answer: CACHE
</span>$<span class="w"> </span>./wordle.py<span class="w"> </span><span class="nv">CHAIR</span><span class="o">=</span>Cha..<span class="w"> </span><span class="nv">CLASH</span><span class="o">=</span>C.a.h<span class="w"> </span><span class="nv">CATCH</span><span class="o">=</span>CA.ch<span class="w">
</span>CACHE<span class="w">
</span>CAHOW<span class="w">

</span><span class="c1"># answer: TOXIC
</span>$<span class="w"> </span>./wordle.py<span class="w"> </span><span class="nv">LEAKS</span><span class="o">=</span>.....<span class="w"> </span><span class="nv">MIGHT</span><span class="o">=</span>.i..t<span class="w"> </span><span class="nv">BLITZ</span><span class="o">=</span>..it.<span class="w"> </span><span class="nv">OPTIC</span><span class="o">=</span>o.tIC<span class="w"> </span><span class="nv">TONIC</span><span class="o">=</span>TO.IC<span class="w">
</span>TORIC<span class="w">
</span>TOXIC
</pre>
<p>This looks right
but there are some subtle bugs in the code.</p>
</div>
<div class="section" id="fifty-is-the-new-witty">
<h2>Fifty is the new Witty</h2>
<p>Here we expect to find <tt class="docutils literal">FIFTY</tt>, but no words match:</p>
<pre class="code bash literal-block">
<span class="c1"># answer: FIFTY
</span>$<span class="w"> </span>./wordle.py<span class="w"> </span><span class="nv">HARES</span><span class="o">=</span>.....<span class="w"> </span><span class="nv">BUILT</span><span class="o">=</span>..i.t<span class="w"> </span><span class="nv">TIMID</span><span class="o">=</span>tI...<span class="w"> </span><span class="nv">PINTO</span><span class="o">=</span>.I.T.<span class="w"> </span><span class="nv">WITTY</span><span class="o">=</span>.I.TY<span class="w">
</span>--None--
</pre>
<p>Let's take a look at the state of the <tt class="docutils literal">WordleGuess&shy;es</tt> instance:</p>
<pre class="code pycon literal-block">
<span class="gp">&gt;&gt;&gt; </span><span class="n">guess_scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">GuessScore</span><span class="o">.</span><span class="n">make</span><span class="p">(</span><span class="n">gs</span><span class="p">)</span> <span class="k">for</span> <span class="n">gs</span> <span class="ow">in</span><span class="w">
</span><span class="go">        &quot;HARES=..... BUILT=..i.t TIMID=tI... PINTO=.I.T. WITTY=.I.TY&quot;.split()]

</span><span class="gp">&gt;&gt;&gt; </span><span class="n">wg</span> <span class="o">=</span> <span class="n">WordleGuesses</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">guess_scores</span><span class="p">)</span><span class="w">
</span><span class="gp">&gt;&gt;&gt; </span><span class="n">wg</span><span class="w">
</span><span class="go">WordleGuesses(mask=[None, 'I', None, 'T', 'Y'], valid={'T', 'I', 'Y'}, invalid={
'A', 'E', 'D', 'M', 'U', 'H', 'I', 'B', 'L', 'T', 'P', 'O', 'R', 'W', 'N', 'S'},
wrong_spot=[{'T'}, set(), {'I'}, set(), {'T'}], guess_scores=[GuessScore(guess='HARES',
score='.....', tiles=[&lt;TileState.ABSENT: TileState(value=3, emoji='‚¨õ', color='Black',
css_color='#838184')&gt;, &lt;TileState.ABSENT: TileState(value=3, emoji='‚¨õ', color='Black',
css_color='#838184')&gt;,
    ... much snipped ...</span>
</pre>
<p>That's ugly.</p>
</div>
<div class="section" id="better-string-representation">
<h2>Better String Rep&shy;re&shy;sen&shy;ta&shy;tion</h2>
<p>Let's write a few helper functions to improve the <tt class="docutils literal">__repr__</tt>:</p>
<!-- wordle3 -->
<pre class="code python literal-block">
<span class="k">def</span> <span class="nf">letter_set</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span><span class="w">
</span>    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="w">

</span><span class="k">def</span> <span class="nf">letter_sets</span><span class="p">(</span><span class="n">ls</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span><span class="w">
</span>    <span class="k">return</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">letter_set</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">or</span> <span class="s2">&quot;-&quot;</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">ls</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span><span class="w">

</span><span class="k">def</span> <span class="nf">dash_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]):</span><span class="w">
</span>    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">m</span> <span class="ow">or</span> <span class="s2">&quot;-&quot;</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mask</span><span class="p">)</span><span class="w">

</span><span class="k">class</span> <span class="nc">WordleGuesses</span><span class="p">:</span><span class="w">
</span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span><span class="w">
</span>        <span class="n">mask</span> <span class="o">=</span> <span class="n">dash_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span><span class="w">
</span>        <span class="n">valid</span> <span class="o">=</span> <span class="n">letter_set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">valid</span><span class="p">)</span><span class="w">
</span>        <span class="n">invalid</span> <span class="o">=</span> <span class="n">letter_set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">invalid</span><span class="p">)</span><span class="w">
</span>        <span class="n">wrong_spot</span> <span class="o">=</span> <span class="n">letter_sets</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrong_spot</span><span class="p">)</span><span class="w">
</span>        <span class="n">unused</span> <span class="o">=</span> <span class="n">letter_set</span><span class="p">(</span><span class="w">
</span>            <span class="nb">set</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">ascii_uppercase</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">valid</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">invalid</span><span class="p">)</span><span class="w">
</span>        <span class="n">_guess_scores</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">gs</span><span class="si">}</span><span class="s2">|</span><span class="si">{</span><span class="n">gs</span><span class="o">.</span><span class="n">emojis</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="w">
</span>            <span class="k">for</span> <span class="n">gs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">guess_scores</span><span class="p">)]</span><span class="w">
</span>        <span class="k">return</span> <span class="p">(</span><span class="w">
</span>            <span class="sa">f</span><span class="s2">&quot;WordleGuesses(</span><span class="si">{</span><span class="n">mask</span><span class="si">=}</span><span class="s2">, </span><span class="si">{</span><span class="n">valid</span><span class="si">=}</span><span class="s2">, </span><span class="si">{</span><span class="n">invalid</span><span class="si">=}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span><span class="w">
</span>            <span class="sa">f</span><span class="s2">&quot;    </span><span class="si">{</span><span class="n">wrong_spot</span><span class="si">=}</span><span class="s2">, </span><span class="si">{</span><span class="n">unused</span><span class="si">=}</span><span class="s2">)&quot;</span><span class="w">
</span>        <span class="p">)</span>
</pre>
<p>Let's run it again, printing out the instance:</p>
<pre class="code bash literal-block">
<span class="c1"># answer: FIFTY
</span>$<span class="w"> </span>./wordle.py<span class="w"> </span>-v<span class="w"> </span><span class="nv">HARES</span><span class="o">=</span>.....<span class="w"> </span><span class="nv">BUILT</span><span class="o">=</span>..i.t<span class="w"> </span><span class="nv">TIMID</span><span class="o">=</span>tI...<span class="w"> </span><span class="nv">PINTO</span><span class="o">=</span>.I.T.<span class="w"> </span><span class="nv">WITTY</span><span class="o">=</span>.I.TY<span class="w">
</span>WordleGuesses<span class="o">(</span><span class="nv">mask</span><span class="o">=</span><span class="s1">'-I-TY'</span>,<span class="w"> </span><span class="nv">valid</span><span class="o">=</span><span class="s1">'ITY'</span>,<span class="w"> </span><span class="nv">invalid</span><span class="o">=</span><span class="s1">'ABDEHILMNOPRSTUW'</span>,<span class="w">
    </span><span class="nv">wrong_spot</span><span class="o">=</span><span class="s1">'[T,-,I,-,T]'</span>,<span class="w"> </span><span class="nv">unused</span><span class="o">=</span><span class="s1">'CFGJKQVXZ'</span><span class="o">)</span><span class="w">
    </span><span class="nv">guess_scores</span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="s1">'HARES=.....|‚¨õ‚¨õ‚¨õ‚¨õ‚¨õ, BUILT=..i.t|‚¨õ‚¨õüü®‚¨õüü®,
        TIMID=tI...|üü®üü©‚¨õ‚¨õ‚¨õ, PINTO=.I.T.|‚¨õüü©‚¨õüü©‚¨õ, WITTY=.I.TY|‚¨õüü©‚¨õüü©üü©'</span><span class="o">]</span><span class="w">
</span>--None--
</pre>
<p>That's a huge im&shy;prove&shy;ment in legibility
over the default string rep&shy;re&shy;sen&shy;ta&shy;tion!</p>
<p>There's a <tt class="docutils literal">T</tt> in both <tt class="docutils literal">valid</tt> and <tt class="docutils literal">invalid</tt>‚Äîtwo sets that should be mutually exclusive.
The first ‚Äúabsent‚Äù <tt class="docutils literal">T</tt> at position 3 in <tt class="docutils literal">WITTY</tt>
has poisoned the second  <tt class="docutils literal">T</tt> at position 4, which is ‚Äúcorrect‚Äù.
The <tt class="docutils literal">T</tt> at position 1 in <tt class="docutils literal">TIMID</tt> and
the <tt class="docutils literal">T</tt> at position 5 in <tt class="docutils literal">BUILT</tt> are ‚Äúpresent‚Äù
because they are the only <tt class="docutils literal">T</tt> in those guesses.</p>
<p>When there are two <tt class="docutils literal">T</tt>s in a guess, but only one <tt class="docutils literal">T</tt> in the answer,
one of the <tt class="docutils literal">T</tt>s will either be ‚Äúcorrect‚Äù or ‚Äúpresent‚Äù.
The second, su&shy;per&shy;flu&shy;ous <tt class="docutils literal">T</tt> will be ‚Äúabsent‚Äù.</p>
</div>
<div class="section" id="first-attempt-at-fixing-the-bug">
<h2>First Attempt at Fixing the Bug</h2>
<p>Let's modify <tt class="docutils literal">WordleGuess&shy;es.parse</tt> slightly to address that.
When we get an <tt class="docutils literal">ABSENT</tt> tile,
we should add that letter to <tt class="docutils literal">invalid</tt>
only if it's not already in <tt class="docutils literal">valid</tt>.</p>
<!-- wordle4 -->
<pre class="code python literal-block">
<span class="k">class</span> <span class="nc">WordleGuesses</span><span class="p">:</span><span class="w">
</span>    <span class="nd">&#64;classmethod</span><span class="w">
</span>    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">guess_scores</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">GuessScore</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;WordleGuesses&quot;</span><span class="p">:</span><span class="w">
</span>        <span class="n">mask</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">WORDLE_LEN</span><span class="w">
</span>        <span class="n">valid</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span><span class="w">
</span>        <span class="n">invalid</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span><span class="w">
</span>        <span class="n">wrong_spot</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">WORDLE_LEN</span><span class="p">)]</span><span class="w">

</span>        <span class="k">for</span> <span class="n">gs</span> <span class="ow">in</span> <span class="n">guess_scores</span><span class="p">:</span><span class="w">
</span>            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">gs</span><span class="o">.</span><span class="n">tiles</span><span class="p">,</span> <span class="n">gs</span><span class="o">.</span><span class="n">guess</span><span class="p">)):</span><span class="w">
</span>                <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="n">TileState</span><span class="o">.</span><span class="n">CORRECT</span><span class="p">:</span><span class="w">
</span>                    <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="w">
</span>                    <span class="n">valid</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w">
</span>                <span class="k">elif</span> <span class="n">t</span> <span class="ow">is</span> <span class="n">TileState</span><span class="o">.</span><span class="n">PRESENT</span><span class="p">:</span><span class="w">
</span>                    <span class="n">wrong_spot</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w">
</span>                    <span class="n">valid</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w">
</span>                <span class="k">elif</span> <span class="n">t</span> <span class="ow">is</span> <span class="n">TileState</span><span class="o">.</span><span class="n">ABSENT</span><span class="p">:</span><span class="w">
</span>                    <span class="k">if</span> <span class="n">g</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid</span><span class="p">:</span>  <span class="c1"># &lt;&lt;&lt; new</span><span class="w">
</span>                        <span class="n">invalid</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w">

</span>        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">valid</span><span class="p">,</span> <span class="n">invalid</span><span class="p">,</span> <span class="n">wrong_spot</span><span class="p">,</span> <span class="n">guess_scores</span><span class="p">)</span>
</pre>
<p>Does it work? Yes!
Now we have <tt class="docutils literal">FIFTY</tt>.</p>
<pre class="code bash literal-block">
<span class="c1"># answer: FIFTY
</span>$<span class="w"> </span>./wordle.py<span class="w"> </span>-v<span class="w"> </span><span class="nv">HARES</span><span class="o">=</span>.....<span class="w"> </span><span class="nv">BUILT</span><span class="o">=</span>..i.t<span class="w"> </span><span class="nv">TIMID</span><span class="o">=</span>tI...<span class="w"> </span><span class="nv">PINTO</span><span class="o">=</span>.I.T.<span class="w"> </span><span class="nv">WITTY</span><span class="o">=</span>.I.TY<span class="w">
</span>WordleGuesses<span class="o">(</span><span class="nv">mask</span><span class="o">=</span><span class="s1">'-I-TY'</span>,<span class="w"> </span><span class="nv">valid</span><span class="o">=</span><span class="s1">'ITY'</span>,<span class="w"> </span><span class="nv">invalid</span><span class="o">=</span><span class="s1">'ABDEHLMNOPRSUW'</span>,<span class="w">
    </span><span class="nv">wrong_spot</span><span class="o">=</span><span class="s1">'[T,-,I,-,T]'</span>,<span class="w"> </span><span class="nv">unused</span><span class="o">=</span><span class="s1">'CFGJKQVXZ'</span><span class="o">)</span><span class="w">
</span>FIFTY<span class="w">
</span>JITTY<span class="w">
</span>KITTY<span class="w">
</span>ZITTY
</pre>
<p>But we also have <tt class="docutils literal">JITTY</tt>, <tt class="docutils literal">KITTY</tt>, and <tt class="docutils literal">ZITTY</tt>,
which should not been considered eligible
since <tt class="docutils literal">WITTY</tt> was eliminated for the <tt class="docutils literal">T</tt> at position 3.
We'll come back to this soon.</p>
</div>
<div class="section" id="the-problem-of-repeated-letters">
<h2>The Problem of Repeated Letters</h2>
<p>There's a problem that we haven't grappled with properly yet:
<em>repeated letters</em> in a guess or in an answer.
We've made an implicit assumption that there are five distinct letters
in each guess and in the answer.</p>
<p>Here's an example that fails with the original <tt class="docutils literal">parse</tt>:</p>
<pre class="code bash literal-block">
<span class="c1"># answer: EMPTY
</span>$<span class="w"> </span>./wordle.py<span class="w"> </span>-v<span class="w"> </span><span class="nv">LODGE</span><span class="o">=</span>....e<span class="w"> </span><span class="nv">WIPER</span><span class="o">=</span>..Pe.<span class="w"> </span><span class="nv">TEPEE</span><span class="o">=</span>teP..<span class="w"> </span><span class="nv">EXPAT</span><span class="o">=</span>E.P.t<span class="w">
</span>WordleGuesses<span class="o">(</span><span class="nv">mask</span><span class="o">=</span><span class="s1">'E-P--'</span>,<span class="w"> </span><span class="nv">valid</span><span class="o">=</span><span class="s1">'EPT'</span>,<span class="w"> </span><span class="nv">invalid</span><span class="o">=</span><span class="s1">'ADEGILORWX'</span>,<span class="w">
    </span><span class="nv">wrong_spot</span><span class="o">=</span><span class="s1">'[T,E,-,E,ET]'</span>,<span class="w"> </span><span class="nv">unused</span><span class="o">=</span><span class="s1">'BCFHJKMNQSUVYZ'</span><span class="o">)</span><span class="w">
</span>--None--
</pre>
<p>but works with the current <tt class="docutils literal">parse</tt>:</p>
<pre class="code bash literal-block">
<span class="c1"># answer: EMPTY
</span>$<span class="w"> </span>./wordle.py<span class="w"> </span>-v<span class="w"> </span><span class="nv">LODGE</span><span class="o">=</span>....e<span class="w"> </span><span class="nv">WIPER</span><span class="o">=</span>..Pe.<span class="w"> </span><span class="nv">TEPEE</span><span class="o">=</span>teP..<span class="w"> </span><span class="nv">EXPAT</span><span class="o">=</span>E.P.t<span class="w">
</span>WordleGuesses<span class="o">(</span><span class="nv">mask</span><span class="o">=</span><span class="s1">'E-P--'</span>,<span class="w"> </span><span class="nv">valid</span><span class="o">=</span><span class="s1">'EPT'</span>,<span class="w"> </span><span class="nv">invalid</span><span class="o">=</span><span class="s1">'ADGILORWX'</span>,<span class="w">
    </span><span class="nv">wrong_spot</span><span class="o">=</span><span class="s1">'[T,E,-,E,ET]'</span>,<span class="w"> </span><span class="nv">unused</span><span class="o">=</span><span class="s1">'BCFHJKMNQSUVYZ'</span><span class="o">)</span><span class="w">
</span>EMPTS<span class="w">
</span>EMPTY
</pre>
<p>Note that there is no longer an <tt class="docutils literal">E</tt> in <tt class="docutils literal">invalid</tt>.
In <tt class="docutils literal">TEPEE=teP..</tt>, the <tt class="docutils literal">E</tt> in position 2 is considered ‚Äúpresent‚Äù,
while the two <tt class="docutils literal">E</tt>s in positions 4 and 5 are marked ‚Äúabsent‚Äù.
This tells us that there is only one <tt class="docutils literal">E</tt> in the answer.
Since <tt class="docutils literal">P</tt> is correct in position 3 of <tt class="docutils literal">TEPEE</tt>,
the <tt class="docutils literal">E</tt> must be in position 1.
This is confirmed by the subsequent <tt class="docutils literal">EXPAT=E.P.t</tt>,
where the initial <tt class="docutils literal">E</tt> is marked ‚Äúcorrect‚Äù.</p>
<p>Our previous un&shy;der&shy;stand&shy;ing of ‚Äúabsent‚Äù was too simple.
An ‚Äúabsent‚Äù tile can mean one of two things:</p>
<ol class="arabic simple">
<li>This letter is not in the answer at all‚Äîthe usual case.</li>
<li>If another copy of this letter
is ‚Äúcorrect‚Äù or ‚Äúpresent‚Äù elsewhere in the same guess (i.e., <em>valid</em>),
the letter is su&shy;per&shy;flu&shy;ous at this position.
The guess has more instances of this letter than the answer does.</li>
</ol>
<p>Consider the results here:</p>
<pre class="code bash literal-block">
<span class="c1"># answer: STYLE
</span>$<span class="w"> </span>./wordle.py<span class="w"> </span>-v<span class="w"> </span><span class="nv">GROAN</span><span class="o">=</span>.....<span class="w"> </span><span class="nv">WHILE</span><span class="o">=</span>...LE<span class="w"> </span><span class="nv">BELLE</span><span class="o">=</span>...LE<span class="w"> </span><span class="nv">TUPLE</span><span class="o">=</span>t..LE<span class="w"> </span><span class="nv">STELE</span><span class="o">=</span>ST.LE<span class="w">
</span>WordleGuesses<span class="o">(</span><span class="nv">mask</span><span class="o">=</span><span class="s1">'ST-LE'</span>,<span class="w"> </span><span class="nv">valid</span><span class="o">=</span><span class="s1">'ELST'</span>,<span class="w"> </span><span class="nv">invalid</span><span class="o">=</span><span class="s1">'ABGHINOPRUW'</span>,<span class="w">
    </span><span class="nv">wrong_spot</span><span class="o">=</span><span class="s1">'[T,-,-,-,-]'</span>,<span class="w"> </span><span class="nv">unused</span><span class="o">=</span><span class="s1">'CDFJKMQVXYZ'</span><span class="o">)</span><span class="w">
</span>STELE<span class="w">
</span>STYLE
</pre>
<p><tt class="docutils literal">STELE</tt> was an incorrect guess,
so it should not have been offered as an eligible word.
<tt class="docutils literal">E</tt>&nbsp;is valid in position 5, but wrong in position 3.</p>
<p>Another example:</p>
<pre class="code bash literal-block">
<span class="c1"># answer: WRITE
</span>$<span class="w"> </span>./wordle.py<span class="w"> </span>-v<span class="w"> </span><span class="nv">SABER</span><span class="o">=</span>...er<span class="w"> </span><span class="nv">REFIT</span><span class="o">=</span>re.it<span class="w"> </span><span class="nv">TRITE</span><span class="o">=</span>.RITE<span class="w">
</span>WordleGuesses<span class="o">(</span><span class="nv">mask</span><span class="o">=</span><span class="s1">'-RITE'</span>,<span class="w"> </span><span class="nv">valid</span><span class="o">=</span><span class="s1">'EIRT'</span>,<span class="w"> </span><span class="nv">invalid</span><span class="o">=</span><span class="s1">'ABFS'</span>,<span class="w">
    </span><span class="nv">wrong_spot</span><span class="o">=</span><span class="s1">'[R,E,-,EI,RT]'</span>,<span class="w"> </span><span class="nv">unused</span><span class="o">=</span><span class="s1">'CDGHJKLMNOPQUVWXYZ'</span><span class="o">)</span><span class="w">
</span>TRITE<span class="w">
</span>URITE<span class="w">
</span>WRITE
</pre>
<p><tt class="docutils literal">TRITE</tt> was an incorrect guess,
so it should not have been offered.
<tt class="docutils literal">4:T</tt> is valid, <tt class="docutils literal">1:T</tt> is wrong.</p>
</div>
<div class="section" id="fixing-repeated-absent-letters">
<h2>Fixing Repeated Absent Letters</h2>
<p>We can fix this by making two passes through the tiles
for each guess‚Äìs&shy;core pair.</p>
<ol class="arabic simple">
<li>Handle ‚Äúcorrect‚Äù and ‚Äúpresent‚Äù tiles as before.</li>
<li>Add ‚Äúabsent‚Äù tiles to either <tt class="docutils literal">invalid</tt> or <tt class="docutils literal">wrong_spot</tt>.</li>
</ol>
<p>We need the second pass to handle a case like <tt class="docutils literal"><span class="pre">WITTY=.I.TY</span></tt>,
where the ‚Äúabsent‚Äù <tt class="docutils literal">3:T</tt> precedes the ‚Äúcorrect‚Äù <tt class="docutils literal">4:T</tt>:
the <tt class="docutils literal">valid</tt> set must be fully updated before we process ‚Äúabsent‚Äù tiles.</p>
<!-- wordle5 -->
<pre class="code python literal-block">
<span class="k">class</span> <span class="nc">WordleGuesses</span><span class="p">:</span><span class="w">
</span>    <span class="nd">&#64;classmethod</span><span class="w">
</span>    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">guess_scores</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">GuessScore</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;WordleGuesses&quot;</span><span class="p">:</span><span class="w">
</span>        <span class="n">mask</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">WORDLE_LEN</span><span class="p">)]</span><span class="w">
</span>        <span class="n">valid</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span><span class="w">
</span>        <span class="n">invalid</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span><span class="w">
</span>        <span class="n">wrong_spot</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">WORDLE_LEN</span><span class="p">)]</span><span class="w">

</span>        <span class="k">for</span> <span class="n">gs</span> <span class="ow">in</span> <span class="n">guess_scores</span><span class="p">:</span><span class="w">
</span>            <span class="c1"># First pass for correct and present</span><span class="w">
</span>            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">gs</span><span class="o">.</span><span class="n">tiles</span><span class="p">,</span> <span class="n">gs</span><span class="o">.</span><span class="n">guess</span><span class="p">)):</span><span class="w">
</span>                <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="n">TileState</span><span class="o">.</span><span class="n">CORRECT</span><span class="p">:</span><span class="w">
</span>                    <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="w">
</span>                    <span class="n">valid</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w">
</span>                <span class="k">elif</span> <span class="n">t</span> <span class="ow">is</span> <span class="n">TileState</span><span class="o">.</span><span class="n">PRESENT</span><span class="p">:</span><span class="w">
</span>                    <span class="n">wrong_spot</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w">
</span>                    <span class="n">valid</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w">

</span>            <span class="c1"># Second pass for absent letters</span><span class="w">
</span>            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">gs</span><span class="o">.</span><span class="n">tiles</span><span class="p">,</span> <span class="n">gs</span><span class="o">.</span><span class="n">guess</span><span class="p">)):</span><span class="w">
</span>                <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="n">TileState</span><span class="o">.</span><span class="n">ABSENT</span><span class="p">:</span><span class="w">
</span>                    <span class="k">if</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">valid</span><span class="p">:</span><span class="w">
</span>                        <span class="c1"># There are more instances of `g` in `gs.guess`</span><span class="w">
</span>                        <span class="c1"># than in the answer</span><span class="w">
</span>                        <span class="n">wrong_spot</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w">
</span>                    <span class="k">else</span><span class="p">:</span><span class="w">
</span>                        <span class="n">invalid</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w">

</span>        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">valid</span><span class="p">,</span> <span class="n">invalid</span><span class="p">,</span> <span class="n">wrong_spot</span><span class="p">,</span> <span class="n">guess_scores</span><span class="p">)</span>
</pre>
<p>We can see that <tt class="docutils literal">valid</tt> and <tt class="docutils literal">invalid</tt> are disjoint.
The <tt class="docutils literal">is_el&shy;i&shy;gi&shy;ble</tt> method needs no changes.</p>
<p>Let's try the <tt class="docutils literal">WRITE</tt> example again:</p>
<pre class="code bash literal-block">
<span class="c1"># answer: WRITE
</span>$<span class="w"> </span>./wordle.py<span class="w"> </span>-v<span class="w"> </span><span class="nv">SABER</span><span class="o">=</span>...er<span class="w"> </span><span class="nv">REFIT</span><span class="o">=</span>re.it<span class="w"> </span><span class="nv">TRITE</span><span class="o">=</span>.RITE<span class="w">
</span>WordleGuesses<span class="o">(</span><span class="nv">mask</span><span class="o">=</span><span class="s1">'-RITE'</span>,<span class="w"> </span><span class="nv">valid</span><span class="o">=</span><span class="s1">'EIRT'</span>,<span class="w"> </span><span class="nv">invalid</span><span class="o">=</span><span class="s1">'ABFS'</span>,<span class="w">
    </span><span class="nv">wrong_spot</span><span class="o">=</span><span class="s1">'[RT,E,-,EI,RT]'</span>,<span class="w"> </span><span class="nv">unused</span><span class="o">=</span><span class="s1">'CDGHJKLMNOPQUVWXYZ'</span><span class="o">)</span><span class="w">
</span>URITE<span class="w">
</span>WRITE
</pre>
<p>There is now a <tt class="docutils literal">T</tt> in the first <tt class="docutils literal">wrong_spot</tt> entry.</p>
<p>And <tt class="docutils literal">STYLE</tt>?</p>
<pre class="code bash literal-block">
<span class="c1"># answer: STYLE
</span>$<span class="w"> </span>./wordle.py<span class="w"> </span>-v<span class="w"> </span><span class="nv">GROAN</span><span class="o">=</span>.....<span class="w"> </span><span class="nv">WHILE</span><span class="o">=</span>...LE<span class="w"> </span><span class="nv">BELLE</span><span class="o">=</span>...LE<span class="w"> </span><span class="nv">TUPLE</span><span class="o">=</span>t..LE<span class="w"> </span><span class="nv">STELE</span><span class="o">=</span>ST.LE<span class="w">
</span>WordleGuesses<span class="o">(</span><span class="nv">mask</span><span class="o">=</span><span class="s1">'ST-LE'</span>,<span class="w"> </span><span class="nv">valid</span><span class="o">=</span><span class="s1">'ELST'</span>,<span class="w"> </span><span class="nv">invalid</span><span class="o">=</span><span class="s1">'ABGHINOPRUW'</span>,<span class="w">
    </span><span class="nv">wrong_spot</span><span class="o">=</span><span class="s1">'[T,E,EL,-,-]'</span>,<span class="w"> </span><span class="nv">unused</span><span class="o">=</span><span class="s1">'CDFJKMQVXYZ'</span><span class="o">)</span><span class="w">
</span>STYLE
</pre>
<p>Both the second and third <tt class="docutils literal">wrong_spot</tt>s now have an <tt class="docutils literal">E</tt>.
The ‚Äúabsent‚Äù <tt class="docutils literal">3:L</tt> from <tt class="docutils literal">BELLE</tt> is also in the third <tt class="docutils literal">wrong_spot</tt>.</p>
<p>What about some other examples?</p>
<p>In our previous attempt at fixing the bug,
neither <tt class="docutils literal">QUICK</tt> nor <tt class="docutils literal">SPICK</tt> were found
because the first <tt class="docutils literal">C</tt> in <tt class="docutils literal">CHICK</tt> was ‚Äúabsent‚Äù
and thus marked invalid.
Now, the <tt class="docutils literal">valid</tt> and <tt class="docutils literal">invalid</tt> sets are disjoint,
there's a <tt class="docutils literal">C</tt> in the first element of <tt class="docutils literal">wrong_spot</tt>,
and both words are found:</p>
<pre class="code bash literal-block">
<span class="c1"># answer: QUICK
</span>$<span class="w"> </span>./wordle.py<span class="w"> </span>-v<span class="w"> </span><span class="nv">MORAL</span><span class="o">=</span>.....<span class="w"> </span><span class="nv">TWINE</span><span class="o">=</span>..I..<span class="w"> </span><span class="nv">CHICK</span><span class="o">=</span>..ICK<span class="w">
</span>WordleGuesses<span class="o">(</span><span class="nv">mask</span><span class="o">=</span><span class="s1">'--ICK'</span>,<span class="w"> </span><span class="nv">valid</span><span class="o">=</span><span class="s1">'CIK'</span>,<span class="w"> </span><span class="nv">invalid</span><span class="o">=</span><span class="s1">'AEHLMNORTW'</span>,<span class="w">
    </span><span class="nv">wrong_spot</span><span class="o">=</span><span class="s1">'[C,-,-,-,-]'</span>,<span class="w"> </span><span class="nv">unused</span><span class="o">=</span><span class="s1">'BDFGJPQSUVXYZ'</span><span class="o">)</span><span class="w">
</span>QUICK<span class="w">
</span>SPICK
</pre>
<p>As expected, we find only one answer for <tt class="docutils literal">FIFTY</tt> now:</p>
<pre class="code bash literal-block">
<span class="c1"># answer: FIFTY
</span>$<span class="w"> </span>./wordle.py<span class="w"> </span>-v<span class="w"> </span><span class="nv">HARES</span><span class="o">=</span>.....<span class="w"> </span><span class="nv">BUILT</span><span class="o">=</span>..i.t<span class="w"> </span><span class="nv">TIMID</span><span class="o">=</span>tI...<span class="w"> </span><span class="nv">PINTO</span><span class="o">=</span>.I.T.<span class="w"> </span><span class="nv">WITTY</span><span class="o">=</span>.I.TY<span class="w">
</span>WordleGuesses<span class="o">(</span><span class="nv">mask</span><span class="o">=</span><span class="s1">'-I-TY'</span>,<span class="w"> </span><span class="nv">valid</span><span class="o">=</span><span class="s1">'ITY'</span>,<span class="w"> </span><span class="nv">invalid</span><span class="o">=</span><span class="s1">'ABDEHLMNOPRSUW'</span>,<span class="w">
    </span><span class="nv">wrong_spot</span><span class="o">=</span><span class="s1">'[T,-,IT,I,T]'</span>,<span class="w"> </span><span class="nv">unused</span><span class="o">=</span><span class="s1">'CFGJKQVXZ'</span><span class="o">)</span><span class="w">
</span>FIFTY
</pre>
<p>The new <tt class="docutils literal">T</tt> in the third element of <tt class="docutils literal">wrong_spot</tt>
blocks the rhymes for <tt class="docutils literal">WITTY</tt>.</p>
</div>
<div class="section" id="further-optimization-of-the-mask">
<h2>Further Op&shy;ti&shy;miza&shy;tion of the Mask</h2>
<p>There's still room for im&shy;prove&shy;ment.
If you guess <tt class="docutils literal">ANGLE=ANGle</tt>,
it's im&shy;me&shy;di&shy;ate&shy;ly obvious (to a human player) that
you should swap the <tt class="docutils literal">L</tt> and <tt class="docutils literal">E</tt>
to guess <tt class="docutils literal">ANGEL</tt> on your next turn.
Or swap the <tt class="docutils literal">P</tt> and <tt class="docutils literal">T</tt> in <tt class="docutils literal">SPRAT=SpRAt</tt> to guess <tt class="docutils literal">STRAP</tt>.</p>
<p>Similarly, <tt class="docutils literal">TENET=TEN.t</tt> tells you that
the fourth letter of the answer must be <tt class="docutils literal">T</tt>,
while <tt class="docutils literal">CHORE=C.OrE</tt> must have <tt class="docutils literal">2:R</tt>.</p>
<p>A more complex example:</p>
<pre class="code bash literal-block">
<span class="c1"># answer: BURLY
</span>$<span class="w"> </span>./wordle.py<span class="w"> </span>-v<span class="w"> </span><span class="nv">LOWER</span><span class="o">=</span>l...r<span class="w"> </span><span class="nv">FRAIL</span><span class="o">=</span>.r..l<span class="w"> </span><span class="nv">BLURT</span><span class="o">=</span>Blur.<span class="w">
</span>WordleGuesses<span class="o">(</span><span class="nv">mask</span><span class="o">=</span><span class="s1">'B----'</span>,<span class="w"> </span><span class="nv">valid</span><span class="o">=</span><span class="s1">'BLRU'</span>,<span class="w"> </span><span class="nv">invalid</span><span class="o">=</span><span class="s1">'AEFIOTW'</span>,<span class="w">
    </span><span class="nv">wrong_spot</span><span class="o">=</span><span class="s1">'[L,LR,U,R,LR]'</span>,<span class="w"> </span><span class="nv">unused</span><span class="o">=</span><span class="s1">'CDGHJKMNPQSVXYZ'</span><span class="o">)</span>
</pre>
<p>The <tt class="docutils literal">R</tt> is in the wrong spot
in positions 5 (<tt class="docutils literal"><span class="pre">l...r</span></tt>), 2 (<tt class="docutils literal"><span class="pre">.r..l</span></tt>), and 4 (<tt class="docutils literal">Blur.</tt>).
The <tt class="docutils literal">B</tt> is correct in position 1, so <tt class="docutils literal">R</tt> must be in position 3.</p>
<p>The <tt class="docutils literal">L</tt> is in the wrong spot in positions 1, 5, and 2.
<tt class="docutils literal">B</tt> is in position 1, <tt class="docutils literal">R</tt> is now in 3,
so that leaves only position 4 for <tt class="docutils literal">L</tt>.</p>
<p>There remain two pos&shy;si&shy;bil&shy;i&shy;ties for <tt class="docutils literal">U</tt>‚Äîpositions 2 and 5;
the in&shy;for&shy;ma&shy;tion contained in <tt class="docutils literal">mask</tt> and <tt class="docutils literal">wrong_spot</tt>
is not enough to determine where <tt class="docutils literal">U</tt> should go.</p>
<p>The original mask, <tt class="docutils literal"><span class="pre">B----</span></tt>, was due to having only one ‚Äúcorrect‚Äù letter.
Using the cumulative in&shy;for&shy;ma&shy;tion in the guesses and scores,
we can infer a mask of <tt class="docutils literal"><span class="pre">B-RL-</span></tt>.</p>
<p>In all of these cases,
we can find exactly one remaining position
where a ‚Äúpresent‚Äù letter can be placed.
In the <tt class="docutils literal">BURLY</tt> example, it takes two passes:
we couldn't uniquely determine a place for <tt class="docutils literal">L</tt>
until we had already placed <tt class="docutils literal">R</tt>.</p>
<p>Up to now, we've been treating each tile in almost complete isolation.
Let's optimize the mask pro&shy;gram&shy;mat&shy;i&shy;cal&shy;ly.</p>
<p>To account for repeated letters,
such as the two <tt class="docutils literal">T</tt>s in <tt class="docutils literal">TENET=TEN.t</tt>,
we use Python's <tt class="docutils literal">col&shy;lec&shy;tions.Counter</tt> as a <a class="reference external" href="https://dbader.org/blog/sets-and-multiset-in-python">multiset</a>.
<tt class="docutils literal">Counter</tt>'s union operation, <tt class="docutils literal">|=</tt>,
computes the maximum of cor&shy;re&shy;spond&shy;ing counts.</p>
<p>First, we loop through <em>all</em> the guess‚Äìs&shy;core pairs,
building a <tt class="docutils literal">valid</tt> multiset of the ‚Äúcorrect‚Äù and ‚Äúpresent‚Äù letters.
Then we subtract a multiset of the ‚Äúcorrect‚Äù letters,
yielding a multiset of the ‚Äúpresent‚Äù letters.</p>
<p>Second, we loop over <tt class="docutils literal">present</tt>, trying for each letter
to find a single empty position where it can be placed in the mask.
If there is such a position,
we update <tt class="docutils literal">mask2</tt>, remove the letter from <tt class="docutils literal">present</tt>,
and break out of the inner loop.
If there isn't (as in the two pos&shy;si&shy;bil&shy;i&shy;ties for <tt class="docutils literal">U</tt> in <tt class="docutils literal">BURLY</tt>),
then we use the little-known <a class="reference external" href="https://python-notes.curiousefficiency.org/en/latest/python_concepts/break_else.html">break-else</a> construct
to exit from the outer loop.</p>
<p>Finally, we merge <tt class="docutils literal">mask2</tt> into <tt class="docutils literal">self.mask</tt>.
This <tt class="docutils literal">optimize</tt> method is called
from the end of <tt class="docutils literal">WordleGuess&shy;es.parse</tt>.</p>
<!-- wordle -->
<pre class="code python literal-block">
<span class="k">class</span> <span class="nc">WordleGuesses</span><span class="p">:</span><span class="w">
</span>    <span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span><span class="w">
        </span><span class="sd">&quot;&quot;&quot;Use PRESENT tiles to improve `mask`.&quot;&quot;&quot;</span><span class="w">
</span>        <span class="n">mask1</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="w">
</span>        <span class="n">mask2</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">WORDLE_LEN</span><span class="w">
</span>        <span class="c1"># Compute `valid`, a multiset of the correct and present letters in all guesses</span><span class="w">
</span>        <span class="n">valid</span><span class="p">:</span> <span class="n">Counter</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span><span class="w">
</span>        <span class="k">for</span> <span class="n">gs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">guess_scores</span><span class="p">:</span><span class="w">
</span>            <span class="n">valid</span> <span class="o">|=</span> <span class="n">Counter</span><span class="p">(</span><span class="w">
</span>                <span class="n">g</span> <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gs</span><span class="o">.</span><span class="n">guess</span><span class="p">,</span> <span class="n">gs</span><span class="o">.</span><span class="n">tiles</span><span class="p">)</span> <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">TileState</span><span class="o">.</span><span class="n">ABSENT</span><span class="w">
</span>            <span class="p">)</span><span class="w">
</span>        <span class="n">correct</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">mask1</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span><span class="w">
</span>        <span class="c1"># Compute `present`, a multiset of the valid letters</span><span class="w">
</span>        <span class="c1"># whose correct position is not yet known; i.e., PRESENT in any row.</span><span class="w">
</span>        <span class="n">present</span> <span class="o">=</span> <span class="n">valid</span> <span class="o">-</span> <span class="n">correct</span><span class="w">
</span>        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">valid</span><span class="si">=}</span><span class="s2"> </span><span class="si">{</span><span class="n">correct</span><span class="si">=}</span><span class="s2"> </span><span class="si">{</span><span class="n">present</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span><span class="w">

</span>        <span class="k">def</span> <span class="nf">available</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span><span class="w">
</span>            <span class="s2">&quot;Can `c` be placed in slot `i` of `mask2`?&quot;</span><span class="w">
</span>            <span class="k">return</span> <span class="n">mask1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mask2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrong_spot</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w">

</span>        <span class="k">while</span> <span class="n">present</span><span class="p">:</span><span class="w">
</span>            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">present</span><span class="p">:</span><span class="w">
</span>                <span class="n">positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">WORDLE_LEN</span><span class="p">)</span> <span class="k">if</span> <span class="n">available</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span><span class="w">
</span>                <span class="c1"># Is there only one position where `c` can be placed?</span><span class="w">
</span>                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span><span class="w">
</span>                    <span class="n">i</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">
</span>                    <span class="n">mask2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="w">
</span>                    <span class="n">present</span> <span class="o">-=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w">
</span>                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="w">
</span>                    <span class="k">break</span><span class="w">
</span>            <span class="k">else</span><span class="p">:</span><span class="w">
</span>                <span class="c1"># We reach this for-else only if there was no `break` in the for-loop;</span><span class="w">
</span>                <span class="c1"># i.e., no one-element `positions` was found in `present`.</span><span class="w">
</span>                <span class="c1"># We must abandon the outer loop, even though `present` is not empty.</span><span class="w">
</span>                <span class="k">break</span><span class="w">

</span>        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">present</span><span class="si">=}</span><span class="s2"> </span><span class="si">{</span><span class="n">mask2</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span><span class="w">

</span>        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="p">[</span><span class="n">m1</span> <span class="ow">or</span> <span class="n">m2</span> <span class="k">for</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span><span class="p">)]</span><span class="w">
</span>        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="w">
</span>            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">optimize: </span><span class="si">{</span><span class="n">dash_mask</span><span class="p">(</span><span class="n">mask1</span><span class="p">)</span><span class="si">}</span><span class="s2"> | </span><span class="si">{</span><span class="n">dash_mask</span><span class="p">(</span><span class="n">mask2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="w">
</span>            <span class="sa">f</span><span class="s2">&quot; =&gt; </span><span class="si">{</span><span class="n">dash_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="w">
</span>        <span class="p">)</span><span class="w">
</span>        <span class="k">return</span> <span class="n">mask2</span>
</pre>
<p>Here are some examples of it in action.
Going from <tt class="docutils literal"><span class="pre">---ET</span></tt> to <tt class="docutils literal"><span class="pre">-ESET</span></tt>:</p>
<pre class="code bash literal-block">
<span class="c1"># answer: BESET
</span>$<span class="w"> </span>./wordle.py<span class="w"> </span>-vv<span class="w"> </span><span class="nv">CIVET</span><span class="o">=</span>...ET<span class="w"> </span><span class="nv">EGRET</span><span class="o">=</span>e..ET<span class="w"> </span><span class="nv">SLEET</span><span class="o">=</span>s.eET<span class="w">
</span>WordleGuesses<span class="o">(</span><span class="nv">mask</span><span class="o">=</span>---ET,<span class="w"> </span><span class="nv">valid</span><span class="o">=</span>EST,<span class="w"> </span><span class="nv">invalid</span><span class="o">=</span>CGILRV,<span class="w">
    </span><span class="nv">wrong_spot</span><span class="o">=[</span>ES,-,E,-,-<span class="o">]</span>,<span class="w"> </span><span class="nv">unused</span><span class="o">=</span>ABDFHJKMNOPQUWXYZ<span class="o">)</span><span class="w">
</span><span class="nv">valid</span><span class="o">=</span>Counter<span class="o">({</span><span class="s1">'E'</span>:<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="s1">'T'</span>:<span class="w"> </span><span class="m">1</span>,<span class="w"> </span><span class="s1">'S'</span>:<span class="w"> </span><span class="m">1</span><span class="o">})</span><span class="w"> </span><span class="nv">correct</span><span class="o">=</span>Counter<span class="o">({</span><span class="s1">'E'</span>:<span class="w"> </span><span class="m">1</span>,<span class="w"> </span><span class="s1">'T'</span>:<span class="w"> </span><span class="m">1</span><span class="o">})</span><span class="w">
    </span><span class="nv">present</span><span class="o">=</span>Counter<span class="o">({</span><span class="s1">'E'</span>:<span class="w"> </span><span class="m">1</span>,<span class="w"> </span><span class="s1">'S'</span>:<span class="w"> </span><span class="m">1</span><span class="o">})</span><span class="w">
</span><span class="m">2</span><span class="w"> </span>-&gt;<span class="w"> </span>E<span class="w">
</span><span class="m">3</span><span class="w"> </span>-&gt;<span class="w"> </span>S<span class="w">
</span><span class="nv">present</span><span class="o">=</span>Counter<span class="o">()</span><span class="w"> </span><span class="nv">mask2</span><span class="o">=[</span>None,<span class="w"> </span><span class="s1">'E'</span>,<span class="w"> </span><span class="s1">'S'</span>,<span class="w"> </span>None,<span class="w"> </span>None<span class="o">]</span><span class="w">
    </span>optimize:<span class="w"> </span>---ET<span class="w"> </span><span class="p">|</span><span class="w"> </span>-ES--<span class="w"> </span><span class="o">=</span>&gt;<span class="w"> </span>-ESET
</pre>
<p>And from <tt class="docutils literal"><span class="pre">C----</span></tt> to <tt class="docutils literal">CLER-</tt>:</p>
<pre class="code bash literal-block">
<span class="c1"># answer: CLERK
</span>$<span class="w"> </span>./wordle.py<span class="w"> </span>-vv<span class="w"> </span><span class="nv">SINCE</span><span class="o">=</span>...ce<span class="w"> </span><span class="nv">CEDAR</span><span class="o">=</span>Ce..r<span class="w"> </span><span class="nv">CRUEL</span><span class="o">=</span>Cr.el<span class="w">
</span>WordleGuesses<span class="o">(</span><span class="nv">mask</span><span class="o">=</span>C----,<span class="w"> </span><span class="nv">valid</span><span class="o">=</span>CELR,<span class="w"> </span><span class="nv">invalid</span><span class="o">=</span>ADINSU,<span class="w">
    </span><span class="nv">wrong_spot</span><span class="o">=[</span>-,ER,-,CE,ELR<span class="o">]</span>,<span class="w"> </span><span class="nv">unused</span><span class="o">=</span>BFGHJKMOPQTVWXYZ<span class="o">)</span><span class="w">
</span><span class="nv">valid</span><span class="o">=</span>Counter<span class="o">({</span><span class="s1">'C'</span>:<span class="w"> </span><span class="m">1</span>,<span class="w"> </span><span class="s1">'E'</span>:<span class="w"> </span><span class="m">1</span>,<span class="w"> </span><span class="s1">'R'</span>:<span class="w"> </span><span class="m">1</span>,<span class="w"> </span><span class="s1">'L'</span>:<span class="w"> </span><span class="m">1</span><span class="o">})</span><span class="w"> </span><span class="nv">correct</span><span class="o">=</span>Counter<span class="o">({</span><span class="s1">'C'</span>:<span class="w"> </span><span class="m">1</span><span class="o">})</span><span class="w">
    </span><span class="nv">present</span><span class="o">=</span>Counter<span class="o">({</span><span class="s1">'E'</span>:<span class="w"> </span><span class="m">1</span>,<span class="w"> </span><span class="s1">'R'</span>:<span class="w"> </span><span class="m">1</span>,<span class="w"> </span><span class="s1">'L'</span>:<span class="w"> </span><span class="m">1</span><span class="o">})</span><span class="w">
</span><span class="m">3</span><span class="w"> </span>-&gt;<span class="w"> </span>E<span class="w">
</span><span class="m">4</span><span class="w"> </span>-&gt;<span class="w"> </span>R<span class="w">
</span><span class="m">2</span><span class="w"> </span>-&gt;<span class="w"> </span>L<span class="w">
</span><span class="nv">present</span><span class="o">=</span>Counter<span class="o">()</span><span class="w"> </span><span class="nv">mask2</span><span class="o">=[</span>None,<span class="w"> </span><span class="s1">'L'</span>,<span class="w"> </span><span class="s1">'E'</span>,<span class="w"> </span><span class="s1">'R'</span>,<span class="w"> </span>None<span class="o">]</span><span class="w">
    </span>optimize:<span class="w"> </span>C----<span class="w"> </span><span class="p">|</span><span class="w"> </span>-LER-<span class="w"> </span><span class="o">=</span>&gt;<span class="w"> </span>CLER-
</pre>
</div>
<div class="section" id="demanding-an-explanation">
<h2>Demanding an Ex&shy;pla&shy;na&shy;tion</h2>
<p>Would you like to know <em>why</em> a guess is ineligible?
We can do that too.</p>
<pre class="code bash literal-block">
<span class="c1"># answer: ROUSE
</span>$<span class="w"> </span>./wordle.py<span class="w"> </span><span class="nv">THIEF</span><span class="o">=</span>...e.<span class="w"> </span><span class="nv">BLADE</span><span class="o">=</span>....E<span class="w"> </span><span class="nv">GROVE</span><span class="o">=</span>.ro.E<span class="w"> </span><span class="se">\
</span><span class="w">    </span>--words<span class="w"> </span>ROMEO<span class="w"> </span>PROSE<span class="w"> </span>STORE<span class="w"> </span>MURAL<span class="w"> </span>ROUSE<span class="w"> </span>--explain<span class="w">

</span>WordleGuesses<span class="o">(</span><span class="nv">mask</span><span class="o">=</span>----E,<span class="w"> </span><span class="nv">valid</span><span class="o">=</span>EOR,<span class="w"> </span><span class="nv">invalid</span><span class="o">=</span>ABDFGHILTV,<span class="w">
    </span><span class="nv">wrong_spot</span><span class="o">=[</span>-,R,O,E,-<span class="o">]</span>,<span class="w"> </span><span class="nv">unused</span><span class="o">=</span>CJKMNPQSUWXYZ<span class="o">)</span><span class="w">
    </span>guess_scores:<span class="w"> </span><span class="o">[</span><span class="s1">'THIEF=...e.|‚¨õ‚¨õ‚¨õüü®‚¨õ, BLADE=....E|‚¨õ‚¨õ‚¨õ‚¨õüü©,
                    GROVE=.ro.E|‚¨õüü®üü®‚¨õüü©'</span><span class="o">]</span><span class="w">
</span>ROMEO<span class="w">   </span>Mask:<span class="w"> </span>needs<span class="w"> </span>----E<span class="p">;</span><span class="w"> </span>WrongSpot:<span class="w"> </span>has<span class="w"> </span>---E-<span class="w">
</span>PROSE<span class="w">   </span>WrongSpot:<span class="w"> </span>has<span class="w"> </span>-RO--<span class="w">
</span>STORE<span class="w">   </span>Invalid:<span class="w"> </span>has<span class="w"> </span>-T---<span class="p">;</span><span class="w"> </span>WrongSpot:<span class="w"> </span>has<span class="w"> </span>--O--<span class="w">
</span>MURAL<span class="w">   </span>Valid:<span class="w"> </span>missing<span class="w"> </span>EO<span class="p">;</span><span class="w"> </span>Mask:<span class="w"> </span>needs<span class="w"> </span>----E<span class="p">;</span><span class="w"> </span>Invalid:<span class="w"> </span>has<span class="w"> </span>---AL<span class="w">
</span>ROUSE<span class="w">   </span>Eligible
</pre>
<pre class="code bash literal-block">
<span class="c1"># answer: BIRCH
</span>$<span class="w"> </span>./wordle.py<span class="w"> </span><span class="nv">CLAIM</span><span class="o">=</span>c..i.<span class="w"> </span><span class="nv">TRICE</span><span class="o">=</span>.riC.<span class="w"> </span><span class="se">\
</span><span class="w">    </span>--words<span class="w"> </span>INCUR<span class="w"> </span>TAXIS<span class="w"> </span>PRICY<span class="w"> </span>ERICA<span class="w"> </span>BIRCH<span class="w"> </span>--explain<span class="w">

</span>WordleGuesses<span class="o">(</span><span class="nv">mask</span><span class="o">=</span>---C-,<span class="w"> </span><span class="nv">valid</span><span class="o">=</span>CIR,<span class="w"> </span><span class="nv">invalid</span><span class="o">=</span>AELMT,<span class="w">
    </span><span class="nv">wrong_spot</span><span class="o">=[</span>C,R,I,I,-<span class="o">]</span>,<span class="w"> </span><span class="nv">unused</span><span class="o">=</span>BDFGHJKNOPQSUVWXYZ<span class="o">)</span><span class="w">
    </span>guess_scores:<span class="w"> </span><span class="o">[</span><span class="s1">'CLAIM=c..i.|üü®‚¨õ‚¨õüü®‚¨õ, TRICE=.riC.|‚¨õüü®üü®üü©‚¨õ'</span><span class="o">]</span><span class="w">
</span>INCUR<span class="w">   </span>Mask:<span class="w"> </span>needs<span class="w"> </span>---C-<span class="w">
</span>TAXIS<span class="w">   </span>Valid:<span class="w"> </span>missing<span class="w"> </span>CR<span class="p">;</span><span class="w"> </span>Mask:<span class="w"> </span>needs<span class="w"> </span>---C-<span class="p">;</span><span class="w"> </span>Invalid:<span class="w"> </span>has<span class="w"> </span>TA---<span class="p">;</span><span class="w"> </span>WrongSpot:<span class="w"> </span>has<span class="w"> </span>---I-<span class="w">
</span>PRICY<span class="w">   </span>WrongSpot:<span class="w"> </span>has<span class="w"> </span>-RI--<span class="w">
</span>ERICA<span class="w">   </span>Invalid:<span class="w"> </span>has<span class="w"> </span>E---A<span class="p">;</span><span class="w"> </span>WrongSpot:<span class="w"> </span>has<span class="w"> </span>-RI--<span class="w">
</span>BIRCH<span class="w">   </span>Eligible
</pre>
<p>Here's how those ex&shy;pla&shy;na&shy;tions were computed,
using a variation on <tt class="docutils literal">is_el&shy;i&shy;gi&shy;ble</tt>:</p>
<!-- wordle -->
<pre class="code python literal-block">
<span class="k">class</span> <span class="nc">WordleGuesses</span><span class="p">:</span><span class="w">
</span>    <span class="k">def</span> <span class="nf">is_ineligible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span><span class="w">
</span>        <span class="n">reasons</span> <span class="o">=</span> <span class="p">{}</span><span class="w">
</span>        <span class="n">letters</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">word</span><span class="p">}</span><span class="w">
</span>        <span class="k">if</span> <span class="n">missing</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">valid</span> <span class="o">-</span> <span class="p">(</span><span class="n">letters</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">valid</span><span class="p">):</span><span class="w">
</span>            <span class="c1"># Did not have the full set of green+yellow letters known to be valid</span><span class="w">
</span>            <span class="n">reasons</span><span class="p">[</span><span class="s2">&quot;Valid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;missing </span><span class="si">{</span><span class="n">letter_set</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="w">

</span>        <span class="n">mask</span> <span class="o">=</span> <span class="p">[(</span><span class="n">m</span> <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">m</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)]</span><span class="w">
</span>        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span><span class="w">
</span>            <span class="c1"># Couldn't find all the green/correct letters</span><span class="w">
</span>            <span class="n">reasons</span><span class="p">[</span><span class="s2">&quot;Mask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;needs </span><span class="si">{</span><span class="n">dash_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="w">

</span>        <span class="n">invalid</span> <span class="o">=</span> <span class="p">[(</span><span class="n">c</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">invalid</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">word</span><span class="p">]</span><span class="w">
</span>        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">invalid</span><span class="p">):</span><span class="w">
</span>            <span class="c1"># Invalid (black) letters present at specific positions</span><span class="w">
</span>            <span class="n">reasons</span><span class="p">[</span><span class="s2">&quot;Invalid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;has </span><span class="si">{</span><span class="n">dash_mask</span><span class="p">(</span><span class="n">invalid</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="w">

</span>        <span class="n">wrong</span> <span class="o">=</span> <span class="p">[(</span><span class="n">c</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ws</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">ws</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrong_spot</span><span class="p">)]</span><span class="w">
</span>        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">wrong</span><span class="p">):</span><span class="w">
</span>            <span class="c1"># Found some yellow letters: valid letters in wrong position</span><span class="w">
</span>            <span class="n">reasons</span><span class="p">[</span><span class="s2">&quot;WrongSpot&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;has </span><span class="si">{</span><span class="n">dash_mask</span><span class="p">(</span><span class="n">wrong</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="w">

</span>        <span class="k">return</span> <span class="n">reasons</span><span class="w">

</span>    <span class="k">def</span> <span class="nf">find_explanations_</span><span class="p">(</span><span class="w">
</span>        <span class="bp">self</span><span class="p">,</span> <span class="n">vocabulary</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="w">
</span>    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]]:</span><span class="w">
</span>        <span class="n">explanations</span> <span class="o">=</span> <span class="p">[]</span><span class="w">
</span>        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">vocabulary</span><span class="p">:</span><span class="w">
</span>            <span class="n">reasons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ineligible</span><span class="p">(</span><span class="n">word</span><span class="p">)</span><span class="w">
</span>            <span class="n">why</span> <span class="o">=</span> <span class="kc">None</span><span class="w">
</span>            <span class="k">if</span> <span class="n">reasons</span><span class="p">:</span><span class="w">
</span>                <span class="n">why</span> <span class="o">=</span> <span class="s2">&quot;; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="w">
</span>                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ineligible</span><span class="p">(</span><span class="n">word</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">())</span><span class="w">
</span>            <span class="n">explanations</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">word</span><span class="p">,</span> <span class="n">why</span><span class="p">))</span><span class="w">
</span>        <span class="k">return</span> <span class="n">explanations</span>
</pre>
<p>This approach is slower than <tt class="docutils literal">is_el&shy;i&shy;gi&shy;ble</tt>,
though it's not noticeable
when running <tt class="docutils literal">wordle.py</tt> for one set of guess‚Äìs&shy;cores.
I have a test tool (<tt class="docutils literal">score.py</tt>)
that runs through the 200+ games that I've recorded.
Using <tt class="docutils literal">find&shy;_&shy;ex&shy;pla&shy;na&shy;tions</tt>, it took about 10 seconds to run.
Switching to <tt class="docutils literal">find&shy;_el&shy;i&shy;gi&shy;ble</tt>, it dropped to 2 seconds (5x im&shy;prove&shy;ment).
By pre&shy;filter&shy;ing the word list with a regex made from the mask,
the time drops to half a second (further 4x im&shy;prove&shy;ment).</p>
<pre class="code python literal-block">
<span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">m</span> <span class="ow">or</span> <span class="s2">&quot;.&quot;</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">parsed_guesses</span><span class="o">.</span><span class="n">mask</span><span class="p">))</span><span class="w">
</span><span class="n">word_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">vocabulary</span> <span class="k">if</span> <span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="n">w</span><span class="p">)]</span><span class="w">
</span><span class="n">eligible</span> <span class="o">=</span> <span class="n">parsed_guesses</span><span class="o">.</span><span class="n">find_eligible</span><span class="p">(</span><span class="n">word_list</span><span class="p">)</span>
</pre>
</div>
<div class="section" id="finally">
<h2>Finally</h2>
<p>I thought I knew a lot about solving Wordle pro&shy;gram&shy;mat&shy;i&shy;cal&shy;ly
when I started this long post a month ago.
As I wrote this,
I realized that I could use a few ugly greps
to accomplish the same thing as my Python code;
wrote a tool to render games as HTML and emojis;
spun off a couple of blog posts on
<a class="reference external" href="/blog/2023/09/02/PythonEnumsWithAttributes.html">multi-attribute enu&shy;mer&shy;a&shy;tion</a> and <a class="reference external" href="/blog/2023/09/05/RegexConjunctions.html">regex con&shy;junc&shy;tions</a>;
found and fixed several bugs with repeated letters,
greatly refining my un&shy;der&shy;stand&shy;ing of the nuances;
rewrote the sections on repeated letters re&shy;peat&shy;ed&shy;ly;
added a means to explain in&shy;el&shy;i&shy;gi&shy;bil&shy;i&shy;ty;
and had a minor epiphany about optimizing the mask pro&shy;gram&shy;mat&shy;i&shy;cal&shy;ly.</p>
<p>The full code can be found in my <a class="reference external" href="https://github.com/georgevreilly/wordle">Wordle repository</a>.</p>
</div>
<div class="section" id="other-work">
<h2>Other Work</h2>
<p>I found these articles after I completed the final draft of this post.</p>
<ul class="simple">
<li>Bertsimas and Paskov used <a class="reference external" href="https://mitsloan.mit.edu/ideas-made-to-matter/how-algorithm-solves-wordle">Exact Dynamic Pro&shy;gram&shy;ming</a>
to find <a class="reference external" href="http://wordle-page.s3-website-us-east-1.amazonaws.com/assets/Wordle_Paper_Final.pdf">An Exact and In&shy;ter&shy;pretable Solution to Wordle</a>.</li>
<li><a class="reference external" href="https://yannlandry.photography/blog/wordle-intelligent-solver">Yann Landry's Solver</a> is a little JavaScript and HTML tool
that tries to pick the best next word using a scoring system.</li>
<li><a class="reference external" href="https://www.inspiredpython.com/article/solving-wordle-puzzles-with-basic-python">Solving with Basic Python</a> makes sug&shy;ges&shy;tions for each round
based on word com&shy;mon&shy;al&shy;i&shy;ty.</li>
<li>Some <a class="reference external" href="https://mashable.com/article/wordle-tips-tricks">Tips and Tricks</a> for playing the game.</li>
</ul>
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -_ -->
<!-- Sticking the Wordle stylesheet at the end out of the way -->
<link rel="stylesheet" href="/wordle.css"></div>

    <footer>
        
        
            <p>tagged as
                <a href="/tag/python/" rel="tag">python</a>
                    and
                    
                <a href="/tag/wordle/" rel="tag">wordle</a>
                
            </p>
        
    </footer>
    <div class="comments">
        <div id="disqus_thread"></div>
        <script type="text/javascript">
            var disqus_shortname = 'georgevreilly'; // required: replace example with your forum shortname

            // The following are highly recommended additional parameters. Remove the slashes in front to use.
            var disqus_identifier = "https://www.georgevreilly.com/2023/09/26/ExploringWordle.html";
            var disqus_url = "https://www.georgevreilly.com/2023/09/26/ExploringWordle.html";

            if (window.location.hostname != "localhost") {
                /* * * DON'T EDIT BELOW THIS LINE * * */
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        </script>
        <noscript>
            <p>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></p>
        </noscript>
        <a href="https://disqus.com" class="dsq-brlink">
            blog comments powered by <span class="logo-disqus">Disqus</span>
        </a>
        </div>
</article>


    
    
        <a href="/blog/2023/09/05/RegexConjunctions.html" class="page floatright">
        Regex Conjunctions &raquo;
        </a>
    
    
<footer>
    
    
    <p>written by <a href="mailto:george@reilly.org">George V. Reilly</a></p>
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="copyright license">
        <img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="by-nc-sa" />
    </a>
    
    

  </footer>
</body>
</html>
